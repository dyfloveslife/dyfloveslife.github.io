<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Java 容器之 HashMap - Carol&#39;s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Carol" /><meta name="description" content="在日常开发中，我们可以使用 HapMap 中的 get 和 put 方法进行 O(1) 的操作，如此快速的方法到底是怎么实现的？本文将对 HashMap 中的主要方法（get、put、resize）进行说明，对应的版本为 JDK 1.8。不过，为了更加详细的了解 HashMap 的优化过程，同时也会与 JDK 1.7 中的 HashMap 进行比较，从而对 HashMap 有一个较为全面的认识。
" /><meta name="keywords" content="Java, blog, carol" />






<meta name="generator" content="Hugo 0.59.1 with theme even" />


<link rel="canonical" href="http://localhost:1313/2020/02/12/JavaSrc-HashMap/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link href="/dist/even.a289a5a4.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Java 容器之 HashMap" />
<meta property="og:description" content="在日常开发中，我们可以使用 HapMap 中的 get 和 put 方法进行 O(1) 的操作，如此快速的方法到底是怎么实现的？本文将对 HashMap 中的主要方法（get、put、resize）进行说明，对应的版本为 JDK 1.8。不过，为了更加详细的了解 HashMap 的优化过程，同时也会与 JDK 1.7 中的 HashMap 进行比较，从而对 HashMap 有一个较为全面的认识。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/2020/02/12/JavaSrc-HashMap/" />
<meta property="article:published_time" content="2020-02-12T17:02:11+08:00" />
<meta property="article:modified_time" content="2020-02-12T17:36:56+08:00" />
<meta itemprop="name" content="Java 容器之 HashMap">
<meta itemprop="description" content="在日常开发中，我们可以使用 HapMap 中的 get 和 put 方法进行 O(1) 的操作，如此快速的方法到底是怎么实现的？本文将对 HashMap 中的主要方法（get、put、resize）进行说明，对应的版本为 JDK 1.8。不过，为了更加详细的了解 HashMap 的优化过程，同时也会与 JDK 1.7 中的 HashMap 进行比较，从而对 HashMap 有一个较为全面的认识。">


<meta itemprop="datePublished" content="2020-02-12T17:02:11&#43;08:00" />
<meta itemprop="dateModified" content="2020-02-12T17:36:56&#43;08:00" />
<meta itemprop="wordCount" content="4667">



<meta itemprop="keywords" content="Java,JDK,HashMap," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java 容器之 HashMap"/>
<meta name="twitter:description" content="在日常开发中，我们可以使用 HapMap 中的 get 和 put 方法进行 O(1) 的操作，如此快速的方法到底是怎么实现的？本文将对 HashMap 中的主要方法（get、put、resize）进行说明，对应的版本为 JDK 1.8。不过，为了更加详细的了解 HashMap 的优化过程，同时也会与 JDK 1.7 中的 HashMap 进行比较，从而对 HashMap 有一个较为全面的认识。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Carol&#39;s blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Writing</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/2020/01/12/post_summary/">
        <li class="mobile-menu-item">❤文章汇总</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Carol&#39;s blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Writing</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/2020/01/12/post_summary/">❤文章汇总</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Java 容器之 HashMap</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-02-12 </span>
        <div class="post-category">
            <a href="/categories/Java/"> Java </a>
            </div>
          <span class="more-meta"> 4667 words </span>
          <span class="more-meta"> 10 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#总览">总览</a></li>
<li><a href="#实现原理">实现原理</a>
<ul>
<li><a href="#存储单元-node">存储单元 Node</a></li>
<li><a href="#构造函数">构造函数</a></li>
<li><a href="#hash-方法">hash 方法</a></li>
<li><a href="#get-方法">get 方法</a></li>
<li><a href="#put-方法">put 方法</a></li>
<li><a href="#resize-扩容方法">resize 扩容方法</a></li>
</ul></li>
<li><a href="#参考">参考</a></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>在日常开发中，我们可以使用 HapMap 中的 get 和 put 方法进行 O(1) 的操作，如此快速的方法到底是怎么实现的？本文将对 HashMap 中的主要方法（get、put、resize）进行说明，对应的版本为 JDK 1.8。不过，为了更加详细的了解 HashMap 的优化过程，同时也会与 JDK 1.7 中的 HashMap 进行比较，从而对 HashMap 有一个较为全面的认识。</p>

<h1 id="总览">总览</h1>

<p>HashMap 是基于哈希表以<code>key-value</code>的映射方式实现的，一对<code>key-value</code>可以组成类型为<code>Node</code>（JDK 1.8）的存储对象（JDK 1.7 称为 <code>Entry</code>）。这些<code>Node</code>存储在数组中，其中<code>key</code>和<code>value</code>均可以为空（即最多只允许一条记录的 key 为 null，而允许多条记录的 value 为 null），<code>key</code>是唯一的，即重复的<code>key</code>会被覆盖，而<code>value</code>是可以重复的。此外，HashMap 是无序的，同时也是非线程安全的，因为在 JDK 1.7 版本中，<code>数组+链表（头插法）</code>的形式会造成线程安全问题，即链表容易形成环，同时也对之前版本做了许多优化。例如，当链表长度大于 8 时会将链表转换成红黑树；重写了<code>resize</code>方法，在复制元素时避免重新计算键的哈希值以此提高效率等。</p>

<p>而哈希表的实现方式是基于数组，假如知道了某个元素的索引，则可以在 O(1) 的时间内找到对应的元素。某个对象可以通过哈希函数得到存储地址，这些存储地址就是数组的索引，通过对应的索引就可以从数组中找到对应的值。</p>

<p>但如果两个元素分别在进行哈希函数的时候产生了相同的存储地址，则需要通过<code>开放地址法</code>、<code>链地址法</code>、<code>再散列函数法</code>等解决此的问题，而 HashMap 采用<code>数组+链表（JDK 1.8 尾插法）</code>的形式就是基于<code>链地址法</code>进行实现的。如下图所示：</p>

<p><img src="https://i.loli.net/2020/02/12/IKzDMYdq4PgQ5e1.png" alt="image.png" /></p>

<p>下面结合源码进行说明。</p>

<h1 id="实现原理">实现原理</h1>

<h2 id="存储单元-node">存储单元 Node</h2>

<p><code>Node</code>类实现了<code>Map.Entry</code>接口，该<code>Entry</code>表示键值对的映射关系，上图中的每个矩形框代表了一个<code>Node</code>，通过对<code>key</code>的<code>hashCode</code>进行哈希运算，可以得到该<code>Node</code>在数组中的具体位置。数组是 HashMap 的主干，而链表则是为了解决由相同哈希值造成的哈希冲突问题。</p>

<p>如果数组中的某个位置没有形成链表，即当前<code>Node</code>的<code>next</code>为<code>null</code>，则说明该位置还没有造成冲突，这对于查找、添加操作来说是很快的，在 O(1) 时间内可以完成。但如果数组中的当前位置上已经有了链表，对于添加操作来说，则需要对链表进行遍历，如果存在相同的<code>key</code>则将其覆盖，否则进行添加。所以，链表存在的越少，则操作越快。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">static class </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; implements </span><span class="n">Map</span><span class="p">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="err">final int </span><span class="n">hash</span><span class="p">;</span>  <span class="c1">// 用来定位数组索引的位置
</span><span class="c1"></span>    <span class="err">final K </span><span class="n">key</span><span class="p">;</span>     <span class="c1">// 键
</span><span class="c1"></span>    <span class="err">V value</span><span class="p">;</span>         <span class="c1">// 值
</span><span class="c1"></span>    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; next</span><span class="p">;</span>  <span class="c1">// 链表中的下一个 Node
</span><span class="c1"></span>
    <span class="n">Node</span><span class="p">(</span><span class="err">int hash</span><span class="p">,</span> <span class="err">K key</span><span class="p">,</span> <span class="err">V value</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; next</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="na">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="err">public final K getKey</span><span class="p">()</span>        <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
    <span class="err">public final V getValue</span><span class="p">()</span>      <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
    <span class="err">public final String toString</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

    <span class="err">public final int hashCode</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

    <span class="err">public final V setValue</span><span class="p">(</span><span class="err">V newValue</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

    <span class="err">public final boolean equals</span><span class="p">(</span><span class="err">Object o</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span>  <span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="构造函数">构造函数</h2>

<p>HashMap 的源码中一个有 4 个构造函数，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 第一个构造函数
</span><span class="c1"></span><span class="err">public HashMap</span><span class="p">(</span><span class="err">int initialCapacity</span><span class="p">,</span> <span class="err">float loadFactor</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">initialCapacity</span> <span class="o">&lt;</span> <span class="n">0</span><span class="p">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="p">(</span><span class="s">&#34;Illegal initial capacity: &#34;</span> <span class="o">+</span>
                                            <span class="n">initialCapacity</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">initialCapacity</span> <span class="o">&gt;</span> <span class="n">MAXIMUM_CAPACITY</span><span class="p">)</span>
        <span class="n">initialCapacity</span> <span class="o">=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">loadFactor</span> <span class="o">&lt;=</span> <span class="n">0</span> <span class="o">||</span> <span class="n">Float</span><span class="p">.</span><span class="na">isNaN</span><span class="p">(</span><span class="n">loadFactor</span><span class="p">))</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="p">(</span><span class="s">&#34;Illegal load factor: &#34;</span> <span class="o">+</span>
                                            <span class="n">loadFactor</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">loadFactor</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="na">threshold</span> <span class="o">=</span> <span class="n">tableSizeFor</span><span class="p">(</span><span class="n">initialCapacity</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 第二个构造函数
</span><span class="c1"></span><span class="err">public HashMap</span><span class="p">(</span><span class="err">int initialCapacity</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">(</span><span class="n">initialCapacity</span><span class="p">,</span> <span class="n">DEFAULT_LOAD_FACTOR</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 第三个构造函数
</span><span class="c1"></span><span class="err">public HashMap</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">DEFAULT_LOAD_FACTOR</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 第四个构造函数
</span><span class="c1"></span><span class="err">public HashMap</span><span class="p">(</span><span class="n">Map</span><span class="o">&lt;?</span> <span class="err">extends K</span><span class="p">,</span> <span class="o">?</span> <span class="err">extends V</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">DEFAULT_LOAD_FACTOR</span><span class="p">;</span>
    <span class="n">putMapEntries</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>我们平时使用的<code>new HashMap&lt;&gt;()</code>就是第三个构造函数，这里面涉及一些属性，由于这些属性与后文的扩容、get 方法、put 方法以及 resize 方法相关，所以在这里进行说明。如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 默认初始化容量是 16
</span><span class="c1"></span><span class="err">static final int DEFAULT_INITIAL_CAPACITY </span><span class="o">=</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">4</span><span class="p">;</span>

<span class="c1">// 默认负载因子是 0.75
</span><span class="c1"></span><span class="err">static final float DEFAULT_LOAD_FACTOR </span><span class="o">=</span> <span class="n">0</span><span class="p">.</span><span class="na">75f</span><span class="p">;</span>

<span class="err">final float </span><span class="n">loadFactor</span><span class="p">;</span>

<span class="c1">// 当前 HashMap 所能容纳键值对数量的最大值，超过这个值，则需扩容
</span><span class="c1">// 其中 threshold = capacity * loadFactor
</span><span class="c1"></span><span class="err">int threshold</span><span class="p">;</span>

<span class="err">transient int </span><span class="n">modCount</span><span class="p">;</span>

<span class="err">transient int </span><span class="n">size</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<p>其中，<code>threshold</code>是 HashMap 所能容纳的最大数据量<code>Node</code>的个数，也就是键值对的个数，在数组长度一定的情况下，负载因子<code>loadFactor</code>越大，则所能容纳的键值对的个数就越多。通知调节负载因子，可以使程序在时间和空间上具有不同的表现。例如：</p>

<ul>
<li>调低负载因子，则 HashMap 所能容纳的键值对数量变少，扩容时，将<code>旧键值对</code>存储到<code>新键值对</code>的时候，键和键之间产生的碰撞会下降，链表的长度会变短，即以空间换时间；</li>
<li>调高负载因子，则 HashMap 所能容纳的键值对数量变多，空间利用率高，但碰撞也高，链表的长度变长，效率降低，即以时间换空间。</li>
</ul>

<p>而<code>size</code>表示 HashMap 中实际存在的键值对数量，<code>modCount</code>用于记录 HashMap 内部结构发生变化，如 put、remove 等操作。</p>

<p>你可以看到，第一个构造方法的最后两句，初始化了<code>loadFactor</code>和<code>threshold</code>，但有一个函数<code>tableSizeFor</code>需要说明一下，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">static final int tableSizeFor</span><span class="p">(</span><span class="err">int cap</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">int n </span><span class="o">=</span> <span class="n">cap</span> <span class="o">-</span> <span class="n">1</span><span class="p">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">1</span><span class="p">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">2</span><span class="p">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">4</span><span class="p">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">8</span><span class="p">;</span>
    <span class="n">n</span> <span class="o">|=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">16</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="n">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">1</span> <span class="o">:</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="p">)</span> <span class="o">?</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">:</span> <span class="n">n</span> <span class="o">+</span> <span class="n">1</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>上面这段代码用于返回大于或等于 cap 的最小的 2 的幂。例如<code>cap = 13</code>，则返回<code>16</code>；<code>cap = 16</code>，则返回<code>16</code>；<code>cap = 17</code>，则返回<code>32</code>。</p>

<h2 id="hash-方法">hash 方法</h2>

<p>对于任意的对象，只要它的<code>hashCode()</code>的返回值相同，则<code>hash()</code>方法返回的值也是相同的。这里首先进行了<code>h = key.hashCode()</code>，然后将<code>h</code>的高位参与运算，即<code>h ^ (h &gt;&gt;&gt; 16)</code>。通过这种方式，可以将<code>h</code>的高位与低位进行<code>异或</code>操作，以此加大低位信息的随机性，从而增大<code>hash</code>的复杂度。</p>

<p>由于<code>hashCode</code>产生的<code>hash</code>是 int 类型，共 32 位，左边为高 16 位，右边为低 16 位，所以需要向右移 16 位。同时，对于数组长度较小的情况，也能考虑到高位和低位都参与到<code>hash</code>的运算中，同时不会有太大的开销。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">static final int hash</span><span class="p">(</span><span class="err">Object key</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">int h</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="p">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">key</span><span class="p">.</span><span class="na">hashCode</span><span class="p">())</span> <span class="o">^</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">16</span><span class="p">);</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="get-方法">get 方法</h2>

<p>get() 方法的流程如下：</p>

<ul>
<li>首先定位键值对所在桶（数组）的位置；</li>
<li>如果桶上的 key 是要查找的 key，则直接就找到了；</li>
<li>如果桶上的 key 不是要查找的 key，则查看后续节点；</li>
<li>如果后续节点是红黑树结构，则使用红黑树的查找方法进行查找；</li>
<li>如果后续节点是链表结构，则遍历链表进行查找。</li>
</ul>

<p>源码如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 此 get() 调用了 getNode() 方法，在传入 key 之前计算了 key 的 hash
</span><span class="c1"></span><span class="err">public V </span><span class="n">get</span><span class="p">(</span><span class="err">Object key</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; e</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">getNode</span><span class="p">(</span><span class="n">hash</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">key</span><span class="p">))</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">e</span><span class="p">.</span><span class="na">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="err">final Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; getNode</span><span class="p">(</span><span class="err">int hash</span><span class="p">,</span> <span class="err">Object key</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt;[] tab</span><span class="p">;</span> 
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; first</span><span class="p">,</span> <span class="n">e</span><span class="p">;</span> 
    <span class="err">int n</span><span class="p">;</span> <span class="err">K k</span><span class="p">;</span>
    <span class="c1">// 定位键值对所在数组中的位置
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="p">.</span><span class="na">length</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">first</span> <span class="o">=</span> <span class="n">tab</span><span class="p">[(</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="p">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 是否直接命中
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span> <span class="c1">// always check first node
</span><span class="c1"></span>            <span class="p">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">first</span><span class="p">.</span><span class="na">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="p">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">k</span><span class="p">))))</span>
            <span class="k">return</span> <span class="n">first</span><span class="p">;</span>
        <span class="c1">// 如果数组中的 key 不是要查找的 key 的话，则查看后序节点
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">first</span><span class="p">.</span><span class="na">next</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 如果 first 是红黑树，则调用红黑树的查找方法
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="err">first instanceof </span><span class="n">TreeNode</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">((</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">)</span><span class="n">first</span><span class="p">).</span><span class="na">getTreeNode</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
            <span class="k">do</span> <span class="p">{</span>
                <span class="c1">// 遍历链表进行查找
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                    <span class="p">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="na">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="p">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">k</span><span class="p">))))</span>
                    <span class="k">return</span> <span class="n">e</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="na">next</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="put-方法">put 方法</h2>

<p>put() 方法调用了 putVal() 方法，只不过在调用之前对 key 进行了 hash 操作。整体流程如下图所示：</p>

<p><img src="https://i.loli.net/2020/02/12/gMLj7DE5HxXcvlA.png" alt="image.png" /></p>

<p>整体流程如下：</p>

<ul>
<li>1). 判断键值对数组 table[i] 是否为空或 null，是的话则执行 resize() 进行扩容；</li>
<li>2). 如果不满足上述条件，则根据键值 key 计算 hash 值得到插入的数组索引 i，如果 table[i] == null，则直接创建新节点进行添加，再转向 6)；如果 table[i] 不为空，则转向 3)；</li>
<li>3). 判断 table[i] 的首个元素是否和 key 一样，是的话直接覆盖 value，否则转向 4)，这里的相同指的是 hashCode 和 equals；</li>
<li>4). 判断 table[i] 是否为 treeNode（红黑树），如果是红黑树，则在树中直接插入键值对，如果不是红黑树，则转向 5)；</li>
<li>5). 遍历 table[i]，判断链表长度是否大于 8，如果大于 8 则将链表转换成红黑树，在红黑树中执行插入操作，否则插入到链表中；若遍历的过程中 key 已经存在了，则直接覆盖即可；</li>
<li>6). 插入成功后，判断实际存在的键值对的数量 size 是否大于最大容量 threshold，如果超过了，则进行扩容。</li>
</ul>

<p>源码如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public V </span><span class="n">put</span><span class="p">(</span><span class="err">K key</span><span class="p">,</span> <span class="err">V value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">putVal</span><span class="p">(</span><span class="n">hash</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="err">final V </span><span class="n">putVal</span><span class="p">(</span><span class="err">int hash</span><span class="p">,</span> <span class="err">K key</span><span class="p">,</span> <span class="err">V value</span><span class="p">,</span> <span class="err">boolean onlyIfAbsent</span><span class="p">,</span> <span class="err">boolean evict</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt;[] tab</span><span class="p">;</span> 
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; p</span><span class="p">;</span> 
    <span class="err">int n</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
    <span class="c1">// 步骤 1)
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="p">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="p">.</span><span class="na">length</span><span class="p">)</span> <span class="o">==</span> <span class="n">0</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">resize</span><span class="p">()).</span><span class="na">length</span><span class="p">;</span>
    <span class="c1">// 步骤 2)
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">tab</span><span class="p">[</span><span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="p">])</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span>
        <span class="n">tab</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; e</span><span class="p">;</span> <span class="err">K k</span><span class="p">;</span>
        <span class="c1">// 步骤 3)
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
            <span class="p">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="na">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="p">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">k</span><span class="p">))))</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="c1">// 步骤 4)
</span><span class="c1"></span>        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="err">p instanceof </span><span class="n">TreeNode</span><span class="p">)</span>
            <span class="n">e</span> <span class="o">=</span> <span class="p">((</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">)</span><span class="n">p</span><span class="p">).</span><span class="na">putTreeVal</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">tab</span><span class="p">,</span> <span class="n">hash</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
        <span class="c1">// 步骤 5)
</span><span class="c1"></span>        <span class="k">else</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="err">int binCount </span><span class="o">=</span> <span class="n">0</span><span class="p">;</span> <span class="p">;</span> <span class="o">++</span><span class="n">binCount</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 链表中不包含要插入的键值对节点时，则将该节点插在链表的最后，
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="na">next</span><span class="p">)</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">p</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>
                    <span class="c1">// 链表长度大于 8 则转为红黑树
</span><span class="c1"></span>                    <span class="k">if</span> <span class="p">(</span><span class="n">binCount</span> <span class="o">&gt;=</span> <span class="n">TREEIFY_THRESHOLD</span> <span class="o">-</span> <span class="n">1</span><span class="p">)</span> <span class="c1">// -1 for 1st
</span><span class="c1"></span>                        <span class="n">treeifyBin</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="c1">// key 已经存在的话则直接覆盖
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                    <span class="p">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="na">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="p">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">k</span><span class="p">))))</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 判断要插入的键值对是否在 HashMap 中
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// existing mapping for key
</span><span class="c1"></span>            <span class="err">V oldValue </span><span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="na">value</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">onlyIfAbsent</span> <span class="o">||</span> <span class="n">oldValue</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span>
                <span class="n">e</span><span class="p">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
            <span class="n">afterNodeAccess</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">oldValue</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="o">++</span><span class="n">modCount</span><span class="p">;</span>
    <span class="c1">// 步骤 6)
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span>
        <span class="n">resize</span><span class="p">();</span>
    <span class="n">afterNodeInsertion</span><span class="p">(</span><span class="n">evict</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>这里对第 13 行的<code>tab[i = (n - 1) &amp; hash]</code>代码进行解释：通过与运算来得到当前对象在数组中的位置，而 HashMap 底层数组的长度总是 2 的 n 次方的，这是为了进行优化。当数组的长度是 2 的 n 次方时，<code>(n - 1) &amp; hash</code> 操作等价于对数组长度取余运算，即<code>h % n</code>。但位运算比取余运算效率更高，所以这里使用了位运算。</p>

<h2 id="resize-扩容方法">resize 扩容方法</h2>

<p>当 HashMap 中的数组无法装载更多的元素时，则需要对扩大数组的长度，即进行 resize 扩容操作。数组本身并不能进行自身扩容，而是使用一个大的数组替换已有的小的数组。由于 HashMap 中的数组的长度是 2 的次方，阈值大小是数组的长度与负载因子的乘积，当键值对的数量超过阈值后，则进行扩容。在扩容的时候，会按照当前数组长度的 2 倍进行扩容，完成以后需要重新计算键值对的位置，以将它们移动到合适的位置上去。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">final Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt;[] resize</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt;[] oldTab </span><span class="o">=</span> <span class="n">table</span><span class="p">;</span>
    <span class="err">int oldCap </span><span class="o">=</span> <span class="p">(</span><span class="n">oldTab</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="o">?</span> <span class="n">0</span> <span class="o">:</span> <span class="n">oldTab</span><span class="p">.</span><span class="na">length</span><span class="p">;</span>
    <span class="err">int oldThr </span><span class="o">=</span> <span class="n">threshold</span><span class="p">;</span>
    <span class="err">int newCap</span><span class="p">,</span> <span class="n">newThr</span> <span class="o">=</span> <span class="n">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">oldCap</span> <span class="o">&gt;</span> <span class="n">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 如果当前容量已经查过了最大容量，则无法进行扩充
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">oldCap</span> <span class="o">&gt;=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">.</span><span class="na">MAX_VALUE</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">oldTab</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 如果没有超过最大值，则扩充为原来的 2 倍
</span><span class="c1"></span>        <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">newCap</span> <span class="o">=</span> <span class="n">oldCap</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">&amp;&amp;</span>
                    <span class="n">oldCap</span> <span class="o">&gt;=</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="p">)</span>
            <span class="n">newThr</span> <span class="o">=</span> <span class="n">oldThr</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="p">;</span> <span class="c1">// double threshold
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">oldThr</span> <span class="o">&gt;</span> <span class="n">0</span><span class="p">)</span> <span class="c1">// initial capacity was placed in threshold
</span><span class="c1"></span>        <span class="n">newCap</span> <span class="o">=</span> <span class="n">oldThr</span><span class="p">;</span>
    <span class="k">else</span> <span class="p">{</span>               <span class="c1">// zero initial threshold signifies using defaults
</span><span class="c1"></span>        <span class="n">newCap</span> <span class="o">=</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="p">;</span>
        <span class="n">newThr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">DEFAULT_LOAD_FACTOR</span> <span class="o">*</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 计算新的 resize 上限
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">newThr</span> <span class="o">==</span> <span class="n">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="err">float ft </span><span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">newCap</span> <span class="o">*</span> <span class="n">loadFactor</span><span class="p">;</span>
        <span class="n">newThr</span> <span class="o">=</span> <span class="p">(</span><span class="n">newCap</span> <span class="o">&lt;</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">&amp;&amp;</span> <span class="n">ft</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">MAXIMUM_CAPACITY</span> <span class="o">?</span>
                    <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ft</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">.</span><span class="na">MAX_VALUE</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="n">newThr</span><span class="p">;</span>
    <span class="nd">@SuppressWarnings</span><span class="p">({</span><span class="s">&#34;rawtypes&#34;</span><span class="p">,</span><span class="s">&#34;unchecked&#34;</span><span class="p">})</span>
    <span class="c1">// 创建新的桶数组
</span><span class="c1"></span>    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt;[] newTab </span><span class="o">=</span> <span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">[])</span><span class="k">new</span> <span class="n">Node</span><span class="p">[</span><span class="n">newCap</span><span class="p">];</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">newTab</span><span class="p">;</span>
    <span class="c1">// 如果就的桶数组不为空，则遍历每个桶，将键值对映射到新的桶数组中
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">oldTab</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="err">int j </span><span class="o">=</span> <span class="n">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">oldCap</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; e</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">oldTab</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">oldTab</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
                <span class="c1">// 如果桶上只有一个键值对，则直接插入
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span>
                    <span class="n">newTab</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">newCap</span> <span class="o">-</span> <span class="n">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
                <span class="c1">// 如果之前处理冲突的时候转换成了红黑树，则需要对红黑树进行拆分
</span><span class="c1"></span>                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="err">e instanceof </span><span class="n">TreeNode</span><span class="p">)</span>
                    <span class="p">((</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">)</span><span class="n">e</span><span class="p">).</span><span class="na">split</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">newTab</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">oldCap</span><span class="p">);</span>
                <span class="k">else</span> <span class="p">{</span> <span class="c1">// preserve order
</span><span class="c1"></span>                    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; loHead </span><span class="o">=</span> <span class="kc">null</span><span class="p">,</span> <span class="n">loTail</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
                    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; hiHead </span><span class="o">=</span> <span class="kc">null</span><span class="p">,</span> <span class="n">hiTail</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
                    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; next</span><span class="p">;</span>
                    <span class="c1">// 如果之前是采用链表处理冲突的，则将链表节点按原顺序进行分组
</span><span class="c1"></span>                    <span class="k">do</span> <span class="p">{</span>
                        <span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
                        <span class="c1">// 原索引
</span><span class="c1"></span>                        <span class="k">if</span> <span class="p">((</span><span class="n">e</span><span class="p">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="n">oldCap</span><span class="p">)</span> <span class="o">==</span> <span class="n">0</span><span class="p">)</span> <span class="p">{</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">loTail</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span>
                                <span class="n">loHead</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
                            <span class="k">else</span>
                                <span class="n">loTail</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
                            <span class="n">loTail</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
                        <span class="p">}</span>
                        <span class="c1">// 原索引+oldCap
</span><span class="c1"></span>                        <span class="k">else</span> <span class="p">{</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">hiTail</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span>
                                <span class="n">hiHead</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
                            <span class="k">else</span>
                                <span class="n">hiTail</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
                            <span class="n">hiTail</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">);</span>
                    <span class="c1">// 原索引放到桶里
</span><span class="c1"></span>                    <span class="k">if</span> <span class="p">(</span><span class="n">loTail</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">loTail</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
                        <span class="n">newTab</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">loHead</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="c1">// 原索引+oldCap放到桶里
</span><span class="c1"></span>                    <span class="k">if</span> <span class="p">(</span><span class="n">hiTail</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">hiTail</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
                        <span class="n">newTab</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">oldCap</span><span class="p">]</span> <span class="o">=</span> <span class="n">hiHead</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">newTab</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>JDK 1.7 中在扩容的时候需要重新计算 hash，这无疑增加了计算量，效率较低。而 JDK 1.8 则对其进行了改进，在扩充 HashMap 的时候，只需要看看原来的 hash 值新增的那个 bit 位是 1 还是 0 就好了，如果是 0 的话，则索引没变，如果是 1 的话，则索引变成<code>原索引+oldCap</code>。</p>

<p>假设原始的容量是 16，原始的位置在 23，进行<code>(n-1) &amp; hash</code>的时候，计算结果为<code>00111</code>；扩容后容量变为原来的两倍，即 32，再次计算<code>(n-1) &amp; hash</code>得到<code>10111</code>。由于旧的容量<code>16-1=15(1111)</code>比新的容量<code>32-1=31(11111)</code>在比特位上多了一位，并且新增的这个比特位是<code>1</code>，所以新的索引将变成<code>23+16</code>。</p>

<p>这样做的好处是可以保证扩容后每个桶上的节点数必定小于或等于原来桶上的节点数，能够确保不会出现更严重的冲突。</p>

<h1 id="参考">参考</h1>

<ul>
<li><a href="https://zhuanlan.zhihu.com/p/21673805">Java 8 系列之重新认识 HashMap</a></li>
<li><a href="https://www.cnblogs.com/chengxiao/p/6059914.html">HashMap实现原理及源码分析</a></li>
<li><a href="http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/">HashMap 源码详细分析(JDK1.8)</a></li>
<li><a href="https://www.cnblogs.com/xrq730/p/5030920.html">图解集合4：HashMap</a></li>
<li><a href="https://programmer.group/concurrent-hashmap-source-detailed-analysis-jdk-1.8.html">Concurrent HashMap Source Detailed Analysis (JDK 1.8)</a></li>
</ul>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Carol</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2020-02-12
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">Reward</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="https://i.loli.net/2019/11/17/zU4q6LiShYpHrdZ.png">
        <span>wechat</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="https://i.loli.net/2019/11/17/Xnlykx8W3f6DvFi.png">
        <span>alipay</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/Java/">Java</a>
          <a href="/tags/JDK/">JDK</a>
          <a href="/tags/HashMap/">HashMap</a>
          </div>
      <nav class="post-nav">
        
        <a class="next" href="/2020/02/02/mysql-basic-concepts-and-use/">
            <span class="next-text nav-default">MySQL 的基本概念与使用</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'SirCarol';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://twitter.com/SirCarol_" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://github.com/dyfloveslife" class="iconfont icon-github" title="github"></a>
  
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Carol</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
