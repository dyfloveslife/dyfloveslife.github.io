<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Java 容器之 ConcurrentHashMap - Carol&#39;s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Carol" /><meta name="description" content="ConcurrentHashMap 是 HashMap 的一个线程安全并且支持高并发的版本，之前的文章《Java 容器之 HashMap》从 HashMap 的实现原理到各个方法的使用，以及每个方法各自的具体实现都分别进行了介绍，并将 JDK1.7 与 JDK1.8 中的 HashMap 进行了对比。
" /><meta name="keywords" content="Java, blog, carol" />






<meta name="generator" content="Hugo 0.59.1 with theme even" />


<link rel="canonical" href="http://localhost:1313/2020/03/24/JavaSrc-ConcurrentHashMap/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.a289a5a4.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Java 容器之 ConcurrentHashMap" />
<meta property="og:description" content="ConcurrentHashMap 是 HashMap 的一个线程安全并且支持高并发的版本，之前的文章《Java 容器之 HashMap》从 HashMap 的实现原理到各个方法的使用，以及每个方法各自的具体实现都分别进行了介绍，并将 JDK1.7 与 JDK1.8 中的 HashMap 进行了对比。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/2020/03/24/JavaSrc-ConcurrentHashMap/" />
<meta property="article:published_time" content="2020-03-24T14:02:11+08:00" />
<meta property="article:modified_time" content="2020-03-24T14:42:56+08:00" />
<meta itemprop="name" content="Java 容器之 ConcurrentHashMap">
<meta itemprop="description" content="ConcurrentHashMap 是 HashMap 的一个线程安全并且支持高并发的版本，之前的文章《Java 容器之 HashMap》从 HashMap 的实现原理到各个方法的使用，以及每个方法各自的具体实现都分别进行了介绍，并将 JDK1.7 与 JDK1.8 中的 HashMap 进行了对比。">


<meta itemprop="datePublished" content="2020-03-24T14:02:11&#43;08:00" />
<meta itemprop="dateModified" content="2020-03-24T14:42:56&#43;08:00" />
<meta itemprop="wordCount" content="7550">



<meta itemprop="keywords" content="Java,JDK,HashMap,ConcurrentHashMap," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java 容器之 ConcurrentHashMap"/>
<meta name="twitter:description" content="ConcurrentHashMap 是 HashMap 的一个线程安全并且支持高并发的版本，之前的文章《Java 容器之 HashMap》从 HashMap 的实现原理到各个方法的使用，以及每个方法各自的具体实现都分别进行了介绍，并将 JDK1.7 与 JDK1.8 中的 HashMap 进行了对比。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Carol&#39;s blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Writing</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Carol&#39;s blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Writing</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Java 容器之 ConcurrentHashMap</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-03-24 </span>
        <div class="post-category">
            <a href="/categories/Java/"> Java </a>
            </div>
          <span class="more-meta"> 7550 words </span>
          <span class="more-meta"> 16 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#概述">概述</a></li>
<li><a href="#内部实现">内部实现</a>
<ul>
<li><a href="#类的继承关系">类的继承关系</a></li>
<li><a href="#常量定义">常量定义</a></li>
<li><a href="#成员变量">成员变量</a></li>
<li><a href="#内部类-segment">内部类 Segment</a></li>
<li><a href="#内部类-hashentry">内部类 HashEntry</a></li>
<li><a href="#构造函数">构造函数</a></li>
<li><a href="#put-方法">put() 方法</a></li>
<li><a href="#rehash-方法">rehash() 方法</a></li>
<li><a href="#size-方法">size() 方法</a></li>
<li><a href="#jdk1-8-中的-concurrenthashmap">JDK1.8 中的 ConcurrentHashMap</a></li>
</ul></li>
<li><a href="#参考">参考</a></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>ConcurrentHashMap 是 HashMap 的一个线程安全并且支持高并发的版本，之前的文章<a href="https://dyfloveslife.github.io/2020/02/12/JavaSrc-HashMap/">《Java 容器之 HashMap》</a>从 HashMap 的实现原理到各个方法的使用，以及每个方法各自的具体实现都分别进行了介绍，并将 JDK1.7 与 JDK1.8 中的 HashMap 进行了对比。</p>

<p>而本文在此基础上首先会介绍 JDK1.7 版本的 java.util.concurrent 包下的 ConcurrentHashMap 类，解释并说明其实现的原理，然后再引入 JDK1.8 版本，通过对比两个不容版本下的 ConcurrentHashMap ，说明其各自的优缺点以及随着版本升级所做的改进。如有错误，还请指正。</p>

<h1 id="概述">概述</h1>

<p>我们知道 HashMap 不是线程安全的，在多线程并发的情况下容易发生线程安全问题，在进行扩容时也会出现死循环的问题。例如在并发的情况下，线程 1 进行了 put 操作，由于某种情况随后 sleep 了两秒，在这两秒期间，线程 2 修改了线程 1 之前 put 的值，等到线程 1 结束 sleep 后再次 get 获取原来值的时候，就有可能取到的值已经不是原来的值了，就会存在问题。</p>

<p><strong>如果不用 HashMap 的话，用 HashTable 或者同步包装器 Collections.synchronizedMap(Map<K,V> m) 可以吗</strong>？</p>

<p>之前的<a href="https://dyfloveslife.github.io/2020/03/11/JavaSrc-HashTable/">文章</a>中也介绍了 HashTable 这个类，它的底层也是采用<code>数组+链表</code>的形式，只不过是 HashMap 的线程安全版本，即里面的方法是同步的（synchronized），当一个线程访问 HashTable 的同步方法时，其它线程如果要是也访问了该方法，则会出现阻塞或轮询等效率低下的情况。例如线程 1 使用 put 进行添加元素，线程 2 不但不能使用 put 方法，而且也不能使用 get 方法来获取元素，因此如果线程之间竞争越激烈，效率就越低。</p>

<p>而同步包装器也是可以保证线程安全，但是它们都是通过使用一个全局的锁来同步多个线程间的并发访问的，因此就会产生性能问题。所以，还可以使用更好的方式，即 ConcurrentHashMap。在介绍 ConcurrentHashMap 之前，还需要引入<code>锁分段</code>的概念。</p>

<p>在多线程环境下，所有访问 HashTable 的线程都必须竞争同一把锁，所以说效率不高。如果此时有多把锁，每一把锁用于锁住容器中的一部分数据，那么当多线程在访问容器里面的不同数据段的数据时，线程之间就不会存在锁竞争的问题，也就提高了多线程并发效率。</p>

<p>ConcurrentHashMap 就是依靠上述方式实现的，即<code>锁分段</code>技术。在 ConcurrentHashMap 中，首先会将数据以一段一段的方式进行存储，然后给每段的数据分配一把锁，当一个线程占用了锁并访问其中的一段数据时，其它数据段的数据也能被其它线程访问到，多个线程之间在进行访问时互不打扰。</p>

<p><strong>那么 ConcurrentHashMap 是如果保证线程安全、高效并发的呢</strong>？</p>

<ul>
<li>首先就是依靠上述所提到的<code>锁分段</code>技术，在进行写操作时，通过锁分段技术只对当前操作的段进行加锁，而不会影响其它段的数据，正是通过这种加锁以及不加锁的方案可以取保其线程的安全性；</li>
<li>其次，是由 ConcurrentHashMap 的底层结构决定的，ConcurrentHashMap 底层是一个 Segment 数组，每个 Segment 数组中又包含多个桶，这些桶又组成了一个数组，每个桶位置上是由若干个 HashEntry 对象连接起来的链表；</li>
<li>最后，利用 HashEntry 的不变性、volatile 变量的内存可见性以及加锁重读机制，确保了 ConcurrentHashMap 能够进行安全、高效的读操作。</li>
</ul>

<p>整体结构：</p>

<p><center>
<img src="https://i.loli.net/2020/03/24/C3qQk6vg1IhxUPN.png" alt="image.png" />
</center></p>

<h1 id="内部实现">内部实现</h1>

<h2 id="类的继承关系">类的继承关系</h2>

<p><center>
<img src="https://i.loli.net/2020/03/24/LbcP1O9dIjBQi8w.png" alt="image.png" />
</center></p>

<p>如上图所示，ConcurrentHashMap 继承了静态类 AbstractMap，实现了 ConcurrentMap 以及 Serializable 接口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public class </span><span class="n">ConcurrentHashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; extends </span><span class="n">AbstractMap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt;
</span><span class="err">    implements </span><span class="n">ConcurrentMap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Serializable</span> <span class="p">{}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="常量定义">常量定义</h2>

<p>相对于 HashMap，ConcurrentHashMap 中的常量也定义了数组的默认的初始化容量、负载因子等，但比 HashMap 多了许多常量，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 默认的初始化容量，如果没有在构造器中指定的话，则默认为 16.
</span><span class="c1"></span><span class="err">static final int DEFAULT_INITIAL_CAPACITY </span><span class="o">=</span> <span class="n">16</span><span class="p">;</span>

<span class="c1">// 默认的父子啊因子，如果没有在构造器中指定的话，则默认为 0.75.
</span><span class="c1"></span><span class="err">static final float DEFAULT_LOAD_FACTOR </span><span class="o">=</span> <span class="n">0</span><span class="p">.</span><span class="na">75f</span><span class="p">;</span>

<span class="c1">// 默认的并发级别，如果没有在构造器中指定的话，则默认为 16.
</span><span class="c1"></span><span class="err">static final int DEFAULT_CONCURRENCY_LEVEL </span><span class="o">=</span> <span class="n">16</span><span class="p">;</span>

<span class="c1">// 最大容量，如果任何一个带有参数的构造函数隐式的指定了更高的值，则将会调用它;
</span><span class="c1">// 该值必须满足的范围是 2 的幂到 1&lt;&lt;30.
</span><span class="c1"></span><span class="err">static final int MAXIMUM_CAPACITY </span><span class="o">=</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">30</span><span class="p">;</span>

<span class="c1">// 每个 segment 数组的最小容量默认是 2；
</span><span class="c1">// 该值必须是 2 的幂，以避免在延迟构造后立即调整下一次使用的大小.
</span><span class="c1"></span><span class="err">static final int MIN_SEGMENT_TABLE_CAPACITY </span><span class="o">=</span> <span class="n">2</span><span class="p">;</span>

<span class="c1">// segment 数组所允许的最大数量，即 2 的 16 次方；
</span><span class="c1">// 用于绑定构造函数的参数，2 的幂必须小于 1&lt;&lt;24.
</span><span class="c1"></span><span class="err">static final int MAX_SEGMENTS </span><span class="o">=</span> <span class="n">1</span> <span class="o">&lt;&lt;</span> <span class="n">16</span><span class="p">;</span> <span class="c1">// slightly conservative
</span><span class="c1"></span>
<span class="c1">// 此常量在进行 size 等跨段操作时会用到
</span><span class="c1">// 详见 size() 方法部分的介绍
</span><span class="c1"></span><span class="err">static final int RETRIES_BEFORE_LOCK </span><span class="o">=</span> <span class="n">2</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="成员变量">成员变量</h2>

<p>由于引入了<code>锁分段</code>技术，在涉及到若干个由 Segment 实例组成的数组时，这里新增了两个 final 变量，用于定位段，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">final int </span><span class="n">segmentMask</span><span class="p">;</span>

<span class="err">final int </span><span class="n">segmentShift</span><span class="p">;</span>

<span class="err">final Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt;[] segments</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<p>其中，segmentMask 表示用于定位段的掩码值，该值的计算方式是：先计算 key 的哈希值，然后利用哈希值的高位去定位段。segmentShift 表示段内索引的移位值。可以看到， ConcurrentHashMap 的底层使用的是一个 Segment 实例的数组。</p>

<h2 id="内部类-segment">内部类 Segment</h2>

<p>被 final 修饰的 Segment 继承了 ReentrantLock 并实现了序列化，由于继承了可重入锁 ReentrantLock，因此 Segment 就具有了锁的能力。下面是部分成员变量及构造函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 表示链表数组，注意：它是被 volatile 修饰的，能够保证其可见性
</span><span class="c1"></span><span class="err">transient volatile </span><span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt;[] table</span><span class="p">;</span>

<span class="c1">// 表示 Segment 中元素的个数
</span><span class="c1"></span><span class="err">transient int </span><span class="n">count</span><span class="p">;</span>

<span class="c1">// 表示在 Segment 中可变操作的总次数
</span><span class="c1"></span><span class="err">transient int </span><span class="n">modCount</span><span class="p">;</span>

<span class="c1">// 当 Segment 的大小超过此阈值时，将对其进行重哈希操作
</span><span class="c1"></span><span class="err">transient int </span><span class="n">threshold</span><span class="p">;</span>

<span class="c1">// 段的负载因子
</span><span class="c1"></span><span class="err">final float </span><span class="n">loadFactor</span><span class="p">;</span>

<span class="n">Segment</span><span class="p">(</span><span class="err">float lf</span><span class="p">,</span> <span class="err">int threshold</span><span class="p">,</span> <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt;[] tab</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="na">loadFactor</span> <span class="o">=</span> <span class="n">lf</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="na">threshold</span> <span class="o">=</span> <span class="n">threshold</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="na">table</span> <span class="o">=</span> <span class="n">tab</span><span class="p">;</span>
    <span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>通过 Segment 类及其成员变量可以看到，由于采用了分段锁的方式，通过对不同的段分别设置一个锁，然后当某线程对当前段中的数据进行读操作的时候，其它线程可以去操作其它段中的数据，从而不会造成并发问题，但前提是，多个读写操作发生在不同的段上。</p>

<h2 id="内部类-hashentry">内部类 HashEntry</h2>

<p>与 JDK1.7 中 HashMap 的结构类似，HashEntry 包含四部分：被 final 修饰的 hash 和 key，以及被 volatile 修饰的 value 和 next。由于引入了 final 关键字，则保证了 HashEntry 对象几乎是不可变的，而引入了 volatile 关键字，则保证了 value 以及 next 的修改对其它线程是可见的，确保了其它线程读到的是最新的值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">static final class HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="err">final int </span><span class="n">hash</span><span class="p">;</span>
    <span class="err">final K </span><span class="n">key</span><span class="p">;</span>
    <span class="err">volatile V </span><span class="n">value</span><span class="p">;</span>
    <span class="err">volatile HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; next</span><span class="p">;</span>

    <span class="n">HashEntry</span><span class="p">(</span><span class="err">int hash</span><span class="p">,</span> <span class="err">K key</span><span class="p">,</span> <span class="err">V value</span><span class="p">,</span> <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; next</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="na">hash</span> <span class="o">=</span> <span class="n">hash</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
    <span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="构造函数">构造函数</h2>

<p>ConcurrentHashMap 的构造函数与三个参数<code>初始容量</code>、<code>负载因子</code>、<code>并发级别</code>密切相关，在 JDK1.7 中有 5 个构造函数，如下所示：</p>

<p><strong>第一个构造函数</strong>，该构造器需要给定初始化容量、负载因子以及并发等级这三个参数，这里详解一下代码：</p>

<ul>
<li>在第一个 while 循环中，用于计算合适的 sshift 和 ssize，如果 concurrencyLevel 为 16，则 sshift 和 ssize 分别为 4 和 16，则 segmentShift 为 28，segmentMask 为 15；</li>
<li>继续往下面走，此时 c = 16 / 16 = 1，cap = 2；</li>
<li>再往下面走，在初始化 Segment 的地方一直到最后，这里会初始化 Segment 数组 segments 并初始化 segments[0]。因此初始化的 s0 数组长度为 2，负载因子为 0.75，最后初始化了一个 Segment 数组 ss，即容量为 ssize = 16。</li>
</ul>

<p>源码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public ConcurrentHashMap</span><span class="p">(</span><span class="err">int initialCapacity</span><span class="p">,</span> <span class="err">float loadFactor</span><span class="p">,</span> <span class="err">int concurrencyLevel</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">loadFactor</span> <span class="o">&gt;</span> <span class="n">0</span><span class="p">)</span> <span class="o">||</span> <span class="n">initialCapacity</span> <span class="o">&lt;</span> <span class="n">0</span> <span class="o">||</span> <span class="n">concurrencyLevel</span> <span class="o">&lt;=</span> <span class="n">0</span><span class="p">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">concurrencyLevel</span> <span class="o">&gt;</span> <span class="n">MAX_SEGMENTS</span><span class="p">)</span>
        <span class="n">concurrencyLevel</span> <span class="o">=</span> <span class="n">MAX_SEGMENTS</span><span class="p">;</span>
    <span class="c1">// Find power-of-two sizes best matching arguments
</span><span class="c1"></span>    <span class="err">int sshift </span><span class="o">=</span> <span class="n">0</span><span class="p">;</span>
    <span class="err">int ssize </span><span class="o">=</span> <span class="n">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ssize</span> <span class="o">&lt;</span> <span class="n">concurrencyLevel</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">sshift</span><span class="p">;</span>
        <span class="n">ssize</span> <span class="o">&lt;&lt;=</span> <span class="n">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="na">segmentShift</span> <span class="o">=</span> <span class="n">32</span> <span class="o">-</span> <span class="n">sshift</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="na">segmentMask</span> <span class="o">=</span> <span class="n">ssize</span> <span class="o">-</span> <span class="n">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">initialCapacity</span> <span class="o">&gt;</span> <span class="n">MAXIMUM_CAPACITY</span><span class="p">)</span>
        <span class="n">initialCapacity</span> <span class="o">=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="p">;</span>
    <span class="err">int c </span><span class="o">=</span> <span class="n">initialCapacity</span> <span class="o">/</span> <span class="n">ssize</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">ssize</span> <span class="o">&lt;</span> <span class="n">initialCapacity</span><span class="p">)</span>
        <span class="o">++</span><span class="n">c</span><span class="p">;</span>
    <span class="err">int cap </span><span class="o">=</span> <span class="n">MIN_SEGMENT_TABLE_CAPACITY</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">cap</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">)</span>
        <span class="n">cap</span> <span class="o">&lt;&lt;=</span> <span class="n">1</span><span class="p">;</span>
    <span class="c1">// create segments and segments[0]
</span><span class="c1"></span>    <span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; s0 </span><span class="o">=</span> <span class="k">new</span> <span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">loadFactor</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">cap</span> <span class="o">*</span> <span class="n">loadFactor</span><span class="p">),</span> <span class="p">(</span><span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">[])</span><span class="k">new</span> <span class="n">HashEntry</span><span class="p">[</span><span class="n">cap</span><span class="p">]);</span>
    <span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt;[] ss </span><span class="o">=</span> <span class="p">(</span><span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">[])</span><span class="k">new</span> <span class="n">Segment</span><span class="p">[</span><span class="n">ssize</span><span class="p">];</span>
    <span class="n">UNSAFE</span><span class="p">.</span><span class="na">putOrderedObject</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">SBASE</span><span class="p">,</span> <span class="n">s0</span><span class="p">);</span> <span class="c1">// ordered write of segments[0]
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="na">segments</span> <span class="o">=</span> <span class="n">ss</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><strong>第二个构造函数</strong>，通过指定初始化容量、负载因子，使用默认的并发级别（16）创建一个空的 ConcurrentHashMap：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public ConcurrentHashMap</span><span class="p">(</span><span class="err">int initialCapacity</span><span class="p">,</span> <span class="err">float loadFactor</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">(</span><span class="n">initialCapacity</span><span class="p">,</span> <span class="n">loadFactor</span><span class="p">,</span> <span class="n">DEFAULT_CONCURRENCY_LEVEL</span><span class="p">);</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><strong>第三个构造函数</strong>，通过指定初始化容量，使用默认的负载因子（0.75）和默认的并发级别（16）来创建一个空的 ConcurrentHashMap：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public ConcurrentHashMap</span><span class="p">(</span><span class="err">int initialCapacity</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">(</span><span class="n">initialCapacity</span><span class="p">,</span> <span class="n">DEFAULT_LOAD_FACTOR</span><span class="p">,</span> <span class="n">DEFAULT_CONCURRENCY_LEVEL</span><span class="p">);</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><strong>第四个构造函数</strong>，使用默认的初始化容量（16）、默认的负载因子（0.75）以及默认的并发级别（16）来创建一个空的 ConcurrentHashMap：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public ConcurrentHashMap</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">(</span><span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="p">,</span> <span class="n">DEFAULT_LOAD_FACTOR</span><span class="p">,</span> <span class="n">DEFAULT_CONCURRENCY_LEVEL</span><span class="p">);</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><strong>第五个构造函数</strong>，通过构造一个与指定 Map 具有相同映射的 ConcurrentHashMap，使其初始化容量不小于 16，负载因子是 0.75，并发级别是 16，来创建一个 ConcurrentHashMap：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public ConcurrentHashMap</span><span class="p">(</span><span class="n">Map</span><span class="o">&lt;?</span> <span class="err">extends K</span><span class="p">,</span> <span class="o">?</span> <span class="err">extends V</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="na">max</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="na">size</span><span class="p">()</span> <span class="o">/</span> <span class="n">DEFAULT_LOAD_FACTOR</span><span class="p">)</span> <span class="o">+</span> <span class="n">1</span><span class="p">,</span>
                    <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="p">),</span>
            <span class="n">DEFAULT_LOAD_FACTOR</span><span class="p">,</span> <span class="n">DEFAULT_CONCURRENCY_LEVEL</span><span class="p">);</span>
    <span class="n">putAll</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>通过第一个构造函数可知，为了能通过按位与的哈希算法来定位 segments 数组的索引，必须保证 segments 数组的长度是 2 的 n 次方，所以必须计算出一个大于或等于 concurrencyLevel 的最小的 2 的 n 次方的值作为 segments 数组的长度。这里给出一张图，便于理解。</p>

<p><center>
<img src="https://i.loli.net/2020/03/24/WrsxDNQO8EfgUJ9.png" alt="image.png" />
</center></p>

<h2 id="put-方法">put() 方法</h2>

<p>注意到 put 方法中的 key 和 value 均不能为 null，整体流程是先根据 key 来定位到 Segment，然后在对应的 Segment 进行 put 操作，也就是最后的 return 语句。</p>

<p>也就是说，在进行插入或删除元素的时候，必须先通过哈希算法定位到 Segment，即使用 Wang/Jenkins hash 的变种算法对元素的 hashCode 值再次进行哈希操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public V </span><span class="n">put</span><span class="p">(</span><span class="err">K key</span><span class="p">,</span> <span class="err">V value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; s</span><span class="p">;</span>
    <span class="c1">// 这里的 value 不能为空
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="p">();</span>
    <span class="c1">// 根据 key 的哈希值
</span><span class="c1"></span>    <span class="err">int hash </span><span class="o">=</span> <span class="n">hash</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="na">hashCode</span><span class="p">());</span>
    <span class="c1">// 根据哈希值计算待插入对象在 segments 数组中的位置
</span><span class="c1"></span>    <span class="err">int j </span><span class="o">=</span> <span class="p">(</span><span class="n">hash</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">segmentShift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">segmentMask</span><span class="p">;</span>
    <span class="c1">// 检查当前数组中指定位置的 Segment 是否为空
</span><span class="c1"></span>    <span class="c1">// 如果为空，则先初始化 Segment 在进行 put，
</span><span class="c1"></span>    <span class="c1">// 如果不为空，则直接执行 put 操作 
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">((</span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">)</span><span class="n">UNSAFE</span><span class="p">.</span><span class="na">getObject</span>          <span class="c1">// nonvolatile; recheck
</span><span class="c1"></span>            <span class="p">(</span><span class="n">segments</span><span class="p">,</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="n">SSHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">SBASE</span><span class="p">))</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="c1">//  in ensureSegment
</span><span class="c1"></span>        <span class="n">s</span> <span class="o">=</span> <span class="n">ensureSegment</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">hash</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>具体的再哈希操作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">private static int hash</span><span class="p">(</span><span class="err">int h</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">h</span> <span class="o">+=</span> <span class="p">(</span><span class="n">h</span> <span class="o">&lt;&lt;</span>  <span class="n">15</span><span class="p">)</span> <span class="o">^</span> <span class="n">0xffffcd7d</span><span class="p">;</span>
    <span class="n">h</span> <span class="o">^=</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">10</span><span class="p">);</span>
    <span class="n">h</span> <span class="o">+=</span> <span class="p">(</span><span class="n">h</span> <span class="o">&lt;&lt;</span>   <span class="n">3</span><span class="p">);</span>
    <span class="n">h</span> <span class="o">^=</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span>  <span class="n">6</span><span class="p">);</span>
    <span class="n">h</span> <span class="o">+=</span> <span class="p">(</span><span class="n">h</span> <span class="o">&lt;&lt;</span>   <span class="n">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">h</span> <span class="o">&lt;&lt;</span> <span class="n">14</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">h</span> <span class="o">^</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">16</span><span class="p">);</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>如此复杂的再哈希操作其实是为了减少哈希冲突，假如所有的元素都分布在一个 Segment 中，那么势必会存取缓慢。所以上面的计算方式可以使元素均匀的分布在不同的 Segment 上，从而提高容器的存取效率。</p>

<p><strong>其实这里的处理方式的思想与 HashMap 中是一致的，都是为了减少哈希冲突。如果某些元素二进制的底位存在相同的情况的话，在不使用再哈希时，其计算出的结果总是一样的。而实现了上述再哈希函数的话，通过将元素的高位也参与到运算中，这样一来元素的每一位都会参与到哈希值的计算，从而就可以减少哈希冲突</strong>。</p>

<p>注意 put 方法里面的 ensureSegment() 方法，在当前数组中指定位置的 Segment 为空时，则调用此方法。此方法接收一个给定的索引 j，返回一个 Segment <code>键值对</code>对象。具体源码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">private Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; ensureSegment</span><span class="p">(</span><span class="err">int k</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 首先获取到 segments
</span><span class="c1"></span>    <span class="err">final Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt;[] ss </span><span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="na">segments</span><span class="p">;</span>
    <span class="err">long u </span><span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;&lt;</span> <span class="n">SSHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="n">SBASE</span><span class="p">;</span> <span class="c1">// raw offset
</span><span class="c1"></span>    <span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; seg</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">seg</span> <span class="o">=</span> <span class="p">(</span><span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">)</span><span class="n">UNSAFE</span><span class="p">.</span><span class="na">getObjectVolatile</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 使用 segment 0 作为原型，也就是拷贝一份与 segment 0 一样的 segment 
</span><span class="c1"></span>        <span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; proto </span><span class="o">=</span> <span class="n">ss</span><span class="p">[</span><span class="n">0</span><span class="p">];</span> <span class="c1">// use segment 0 as prototype
</span><span class="c1"></span>        <span class="c1">// 容量 cap 为 2
</span><span class="c1"></span>        <span class="err">int cap </span><span class="o">=</span> <span class="n">proto</span><span class="p">.</span><span class="na">table</span><span class="p">.</span><span class="na">length</span><span class="p">;</span>
        <span class="c1">// 负载因子为 0.75
</span><span class="c1"></span>        <span class="err">float lf </span><span class="o">=</span> <span class="n">proto</span><span class="p">.</span><span class="na">loadFactor</span><span class="p">;</span>
        <span class="c1">// 阈值是 1，因为进行了强转
</span><span class="c1"></span>        <span class="err">int threshold </span><span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">cap</span> <span class="o">*</span> <span class="n">lf</span><span class="p">);</span>
        <span class="c1">// 创建 HashEntry 数组
</span><span class="c1"></span>        <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt;[] tab </span><span class="o">=</span> <span class="p">(</span><span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">[])</span><span class="k">new</span> <span class="n">HashEntry</span><span class="p">[</span><span class="n">cap</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">seg</span> <span class="o">=</span> <span class="p">(</span><span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">)</span><span class="n">UNSAFE</span><span class="p">.</span><span class="na">getObjectVolatile</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// recheck
</span><span class="c1"></span>            <span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; s </span><span class="o">=</span> <span class="k">new</span> <span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lf</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">tab</span><span class="p">);</span>
            <span class="k">while</span> <span class="p">((</span><span class="n">seg</span> <span class="o">=</span> <span class="p">(</span><span class="n">Segment</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">)</span><span class="n">UNSAFE</span><span class="p">.</span><span class="na">getObjectVolatile</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">u</span><span class="p">))</span>
                    <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">UNSAFE</span><span class="p">.</span><span class="na">compareAndSwapObject</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="n">seg</span> <span class="o">=</span> <span class="n">s</span><span class="p">))</span>
                    <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">seg</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>之前的 put 方法是根据 key 定位到 Segment，而下面的方法是在确定 Segment 以后，在 Segment 内部进行 put 的方法。因此，下面的 put 方法是类 Segment 中的方法，首先会尝试获取锁，如果获取失败则很定有其它线程存在竞争，则利用 scanAndLockForPut() 自旋获取锁。如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">final V </span><span class="n">put</span><span class="p">(</span><span class="err">K key</span><span class="p">,</span> <span class="err">int hash</span><span class="p">,</span> <span class="err">V value</span><span class="p">,</span> <span class="err">boolean onlyIfAbsent</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 先尝试获取锁，获取到则返回 null，否则执行 scanAndLockForPut 方法
</span><span class="c1"></span>    <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; node </span><span class="o">=</span> <span class="n">tryLock</span><span class="p">()</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">scanAndLockForPut</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">hash</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="err">V oldValue</span><span class="p">;</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="c1">// 此 table 被 volatile 修饰 
</span><span class="c1"></span>        <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt;[] tab </span><span class="o">=</span> <span class="n">table</span><span class="p">;</span>
        <span class="c1">// 计算在 HashEntry[] 中的位置
</span><span class="c1"></span>        <span class="err">int index </span><span class="o">=</span> <span class="p">(</span><span class="n">tab</span><span class="p">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="p">;</span>
        <span class="c1">// 找到 HashEntry[] 中指定位置的第一个节点，即 first 指向桶中链表的第一个节点
</span><span class="c1"></span>        <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; first </span><span class="o">=</span> <span class="n">entryAt</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; e </span><span class="o">=</span> <span class="n">first</span><span class="p">;;)</span> <span class="p">{</span>
            <span class="c1">// 如果当前节点不为空，则遍历该链表
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="err">K k</span><span class="p">;</span>
                <span class="c1">// 如果之前已经存在了该 key，则用新值替换旧值
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="na">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span>
                    <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">k</span><span class="p">)))</span> <span class="p">{</span>
                    <span class="n">oldValue</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="na">value</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">onlyIfAbsent</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">e</span><span class="p">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
                        <span class="o">++</span><span class="n">modCount</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="c1">// 来到下一节点
</span><span class="c1"></span>                <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// 如果当前节点为空，则进入 else
</span><span class="c1"></span>            <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span>
                    <span class="n">node</span><span class="p">.</span><span class="na">setNext</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
                <span class="k">else</span>
                    <span class="c1">// 采用链表的头插法新建一个节点
</span><span class="c1"></span>                    <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">first</span><span class="p">);</span>
                <span class="c1">// 键值对数量加 1
</span><span class="c1"></span>                <span class="err">int c </span><span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="n">1</span><span class="p">;</span>
                <span class="c1">// 如果超过阈值，则扩容
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="n">threshold</span> <span class="o">&amp;&amp;</span> <span class="n">tab</span><span class="p">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="n">MAXIMUM_CAPACITY</span><span class="p">)</span>
                    <span class="n">rehash</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
                <span class="k">else</span>
                    <span class="c1">// 没有超过阈值的话，则放在指定的位置
</span><span class="c1"></span>                    <span class="n">setEntryAt</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
                <span class="o">++</span><span class="n">modCount</span><span class="p">;</span>
                <span class="n">count</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
                <span class="c1">// 桶中不存在相同 key 的节点，所以返回 null
</span><span class="c1"></span>                <span class="n">oldValue</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
        <span class="c1">// 解锁操作
</span><span class="c1"></span>        <span class="n">unlock</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="c1">// put 成功则返回旧值
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">oldValue</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>ConcurrentHashMap 的 put 操作相对于 HashMap 中的 put 操作新增了加锁和解锁的操作，这样才能保证同一时刻只有一个线程拥有修改的权限。这里应该注意一下 put 操作中一开始获取锁的操作，即</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; node </span><span class="o">=</span> <span class="n">tryLock</span><span class="p">()</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">scanAndLockForPut</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">hash</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span></code></pre></td></tr></table>
</div>
</div>
<p>假如当前环境下没有任何线程进行 put 操作，此时如果线程 1 进行了 put 操作，它首先会去尝试获得锁，由于之前没有任何一个线程持有锁，所以线程 1 是可以执行到 tryLock() 并返回 null 的，即线程 1 成功的拿到了锁，然后根据计算找到对应桶的位置，新添加一个键值对。如果此时在线程 1 还没有释放锁的情况下，线程 2 又执行了 put 操作，则假如线程 2 恰好也定位到了和线程 1 同一个段，然后尝试去进行 put 操作，即尝试获取锁。但是线程 1 还没有释放锁，所以线程 2 在一开始的时候会执行<code>scanAndLockForPut</code> 方法，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">private HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; scanAndLockForPut</span><span class="p">(</span><span class="err">K key</span><span class="p">,</span> <span class="err">int hash</span><span class="p">,</span> <span class="err">V value</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 通过 Segment 和 hash 寻找匹配的 HashEntry
</span><span class="c1"></span>    <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; first </span><span class="o">=</span> <span class="n">entryForHash</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
    <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; e </span><span class="o">=</span> <span class="n">first</span><span class="p">;</span>
    <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; node </span><span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="c1">// 重试次数
</span><span class="c1"></span>    <span class="err">int retries </span><span class="o">=</span> <span class="o">-</span><span class="n">1</span><span class="p">;</span> <span class="c1">// negative while locating node
</span><span class="c1"></span>    <span class="c1">// 不断循环，尝试自旋获取锁
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">tryLock</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; f</span><span class="p">;</span> <span class="c1">// to recheck first below
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">retries</span> <span class="o">&lt;</span> <span class="n">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 之前表中不存在
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="c1">// speculatively create node
</span><span class="c1"></span>                    <span class="c1">// 新增一个节点
</span><span class="c1"></span>                    <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>
                <span class="c1">// 将重试次数置为 0
</span><span class="c1"></span>                <span class="n">retries</span> <span class="o">=</span> <span class="n">0</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// 找到了该节点，并且第一个节点就是该节点，重试次数置为 0
</span><span class="c1"></span>            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="na">key</span><span class="p">))</span>
                <span class="n">retries</span> <span class="o">=</span> <span class="n">0</span><span class="p">;</span>
            <span class="c1">// 第一个节点也不是，则继续来到下一个节点
</span><span class="c1"></span>            <span class="k">else</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 尝试次数大于了最大的次数（64）的话，则改为阻塞锁获取，保证能获取成功
</span><span class="c1"></span>        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">retries</span> <span class="o">&gt;</span> <span class="n">MAX_SCAN_RETRIES</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">lock</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 在 MAX_SCAN_RETRIES 次过程中，key 对应的 entry 发生了变化，则从头开始
</span><span class="c1"></span>        <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">retries</span> <span class="o">&amp;</span> <span class="n">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">0</span> <span class="o">&amp;&amp;</span>
                    <span class="p">(</span><span class="n">f</span> <span class="o">=</span> <span class="n">entryForHash</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">hash</span><span class="p">))</span> <span class="o">!=</span> <span class="n">first</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">first</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span> <span class="c1">// re-traverse if entry changed
</span><span class="c1"></span>            <span class="n">retries</span> <span class="o">=</span> <span class="o">-</span><span class="n">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>线程 2 虽然没有得到锁，但是也没有闲着，而是将准备存放的<code>键值对</code>在对应数组中相应的位置给计算了出来，一旦线程 2 获取到了锁，那么就可以利用等待获取锁的这段时间所做的工作，直接定位到具体的位置，从而节省了时间，提高了执行效率。</p>

<p>最后的<code>else if</code>所做的工作就是：如果线程 2 在等待锁的期间，线程 1 将 key 对应的 entry 进行了修改，则线程 2 需要重新确定接下来要定位的位置。</p>

<p><strong>put 小结</strong>：</p>

<ul>
<li>将当前的 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry；</li>
<li>遍历该 HashEntry，如果不为空，则判断传入的 key 和当前遍历到的 key 是否相等，相等则覆盖旧的 value；</li>
<li>如果 node 为空，则新建一个 HashEntry 并加入到 Segment 中，再判断是否需要扩容；</li>
<li>最后会在 finally 中解除之前获得到的锁。</li>
</ul>

<h2 id="rehash-方法">rehash() 方法</h2>

<p>在 Segment 类的 put 方法中，如果键值对的数量超过了阈值，则会进行<code>扩容</code>操作，源码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">private void </span><span class="n">rehash</span><span class="p">(</span><span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; node</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 旧数组
</span><span class="c1"></span>    <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt;[] oldTable </span><span class="o">=</span> <span class="n">table</span><span class="p">;</span>
    <span class="err">int oldCapacity </span><span class="o">=</span> <span class="n">oldTable</span><span class="p">.</span><span class="na">length</span><span class="p">;</span>

    <span class="c1">// 新数组的长度为旧数组的两倍
</span><span class="c1"></span>    <span class="err">int newCapacity </span><span class="o">=</span> <span class="n">oldCapacity</span> <span class="o">&lt;&lt;</span> <span class="n">1</span><span class="p">;</span>
    <span class="c1">// 根据新数组的长度计算新的阈值
</span><span class="c1"></span>    <span class="n">threshold</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">newCapacity</span> <span class="o">*</span> <span class="n">loadFactor</span><span class="p">);</span>
    <span class="c1">// 创建新的表
</span><span class="c1"></span>    <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt;[] newTable </span><span class="o">=</span> <span class="p">(</span><span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">[])</span> <span class="k">new</span> <span class="n">HashEntry</span><span class="p">[</span><span class="n">newCapacity</span><span class="p">];</span>
    <span class="c1">// 用于定位桶
</span><span class="c1"></span>    <span class="err">int sizeMask </span><span class="o">=</span> <span class="n">newCapacity</span> <span class="o">-</span> <span class="n">1</span><span class="p">;</span>

    <span class="c1">// 遍历旧的表
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="err">int i </span><span class="o">=</span> <span class="n">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">oldCapacity</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 依次指向旧表中的每个桶的链表表头
</span><span class="c1"></span>        <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; e </span><span class="o">=</span> <span class="n">oldTable</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="c1">// 当前旧表的桶中的链表不为空
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; next </span><span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
            <span class="c1">// 重新哈希，以便于定位新桶
</span><span class="c1"></span>            <span class="err">int idx </span><span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="n">sizeMask</span><span class="p">;</span>
            <span class="c1">// 如果旧桶中只有一个节点
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span>   <span class="c1">//  Single node on list
</span><span class="c1"></span>                <span class="n">newTable</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
            <span class="k">else</span> <span class="p">{</span> <span class="c1">// Reuse consecutive sequence at same slot
</span><span class="c1"></span>                <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; lastRun </span><span class="o">=</span> <span class="n">e</span><span class="p">;</span>
                <span class="err">int lastIdx </span><span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; last </span><span class="o">=</span> <span class="n">next</span><span class="p">;</span>
                        <span class="n">last</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">;</span>
                        <span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="p">.</span><span class="na">next</span><span class="p">)</span> <span class="p">{</span>
                    <span class="err">int k </span><span class="o">=</span> <span class="n">last</span><span class="p">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="n">sizeMask</span><span class="p">;</span>
                    <span class="c1">// 扩容前后位置发生了变化
</span><span class="c1"></span>                    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">!=</span> <span class="n">lastIdx</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">lastIdx</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
                        <span class="n">lastRun</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="c1">// 将改变的键值对放到新表的对应位置
</span><span class="c1"></span>                <span class="n">newTable</span><span class="p">[</span><span class="n">lastIdx</span><span class="p">]</span> <span class="o">=</span> <span class="n">lastRun</span><span class="p">;</span>
                <span class="c1">// Clone remaining nodes
</span><span class="c1"></span>                <span class="c1">// 将链表中剩下的节点拷贝到新表中
</span><span class="c1"></span>                <span class="k">for</span> <span class="p">(</span><span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; p </span><span class="o">=</span> <span class="n">e</span><span class="p">;</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">lastRun</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="na">next</span><span class="p">)</span> <span class="p">{</span>
                    <span class="err">V v </span><span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="na">value</span><span class="p">;</span>
                    <span class="err">int h </span><span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="na">hash</span><span class="p">;</span>
                    <span class="err">int k </span><span class="o">=</span> <span class="n">h</span> <span class="o">&amp;</span> <span class="n">sizeMask</span><span class="p">;</span>
                    <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; n </span><span class="o">=</span> <span class="n">newTable</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
                    <span class="n">newTable</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashEntry</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="na">key</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 链表头插新的节点
</span><span class="c1"></span>    <span class="err">int nodeIndex </span><span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="n">sizeMask</span><span class="p">;</span> <span class="c1">// add the new node
</span><span class="c1"></span>    <span class="n">node</span><span class="p">.</span><span class="na">setNext</span><span class="p">(</span><span class="n">newTable</span><span class="p">[</span><span class="n">nodeIndex</span><span class="p">]);</span>
    <span class="n">newTable</span><span class="p">[</span><span class="n">nodeIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">newTable</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>这里的扩容是按照 2 的幂次方进行的，所以在扩容之前处于同一个桶中的元素，则在扩容之后要么还在原来的序号的桶里，要么就是原来的需要再加上一个 2 的幂次方。</p>

<p>这里给出<a href="https://user-gold-cdn.xitu.io/2017/12/12/1604851702c89293?imageslim">参考文章</a>中的一张清晰的 put 操作的流程图，涵盖了以上所有的情况，如扩容、不断自旋获取锁等等一些相关的操作。</p>

<p><center>
<img src="https://i.loli.net/2020/03/25/3ipnjm9etsyL47K.png" alt="image.png" />
</center></p>

<h2 id="size-方法">size() 方法</h2>

<p>size 方法用于统计整个 ConcurrentHashMap 中元素的数量，由于所有的元素都分布在不同的段中，因此该操作设计到跨段操作，统计所有 Segment 里元素的数量后进行求和。Segment 中的全局变量 count 用于统计对应 Segment 的元素的数量，那在多线程环境下，我们是不是可以直接将所有的 count 加起来就可以得到 ConcurrentHashMap 的大小了呢？并不能，因为虽然相加时可以获取每个 Segment 中 count 的最新值，但拿到之后累加之前可能 count 的值就发生了变化，计算结果也就不准确了。所以安全的做法是：在调用 size 方法的时候，将 Segment 的 put、remove 以及 clean 方法全部锁住，但这样的做法显然非常低效。</p>

<p>JDK1.7 中的做法是，由于在累加 count 的过程中，之前累加过的 count 发生变化的几率是非常小的，所以 ConcurrentHashMap 先尝试<code>RETRIES_BEFORE_LOCK</code>次（默认为 2）通过不锁住 Segment 的方式来统计各个 Segment 的大小。<strong>如果在统计的过程中 count 发生了变化</strong>，则再采用加锁的方式来统计所有 Segment 的大小。</p>

<p>至于如何判断 count 前后发生了变化，可以利用 Segment 中的 modCount 变量，在 put、remove 和 clean 方法里操作元素时都会将 modCount 进行加 1 操作。<strong>因此只需要统计在 size 前后比较 modCount 是否发生了变化就可以知道容器大小是否发生了变化</strong>。</p>

<h2 id="jdk1-8-中的-concurrenthashmap">JDK1.8 中的 ConcurrentHashMap</h2>

<p>以上介绍的都是 JDK1.7 中的 ConcurrentHashMap，但 JDK1.7 内部的每个小版本之间还有些不同，不过大体的处理流程是相似的，不会有太大的区别。</p>

<p>JDK1.8 中的 ConcurrentHashMap 与 JDK1.7 的不同点在于：</p>

<ul>
<li>抛弃了 JDK1.7 中 Segment 锁分段技术，而是采用 CAS + synchronized 的方式来保证并发的安全性，体现在 put 操作的不同，在 JDK1.8 中则是对数组中单个位置加锁；</li>
<li>将 JDK1.7 中用于存放数据的内部类 HashEntry 替换为内部类 Node，但作用相同。</li>
<li>JDK1.8 的结构转换为数组+链表+红黑树。</li>
</ul>

<p>除此之外，JDK1.8 的 ConcurrentHashMap 也多了一个空参构造，首先看一下 put 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public V </span><span class="n">put</span><span class="p">(</span><span class="err">K key</span><span class="p">,</span> <span class="err">V value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">putVal</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
    <span class="p">}</span>


<span class="err">final V </span><span class="n">putVal</span><span class="p">(</span><span class="err">K key</span><span class="p">,</span> <span class="err">V value</span><span class="p">,</span> <span class="err">boolean onlyIfAbsent</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 不允许存储空 key 和空 value
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">value</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="p">();</span>
    <span class="err">int hash </span><span class="o">=</span> <span class="n">spread</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="na">hashCode</span><span class="p">());</span>
    <span class="err">int binCount </span><span class="o">=</span> <span class="n">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt;[] tab </span><span class="o">=</span> <span class="n">table</span><span class="p">;;)</span> <span class="p">{</span>
        <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; f</span><span class="p">;</span> 
        <span class="err">int n</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">fh</span><span class="p">;</span>
        <span class="c1">// 判断是否要进行初始化工作，如果表为 null，则需要初始化表
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">tab</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="p">.</span><span class="na">length</span><span class="p">)</span> <span class="o">==</span> <span class="n">0</span><span class="p">)</span>
            <span class="n">tab</span> <span class="o">=</span> <span class="n">initTable</span><span class="p">();</span>
        <span class="c1">// 在不需要进行初始化的情况下，通过 key 定位出 Node，也就是 f，
</span><span class="c1"></span>        <span class="c1">// 如果 f 为 null，则说明当前位置可以写入数据，则利用 CAS 尝试写入，失败则自旋
</span><span class="c1"></span>        <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">f</span> <span class="o">=</span> <span class="n">tabAt</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="p">))</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">casTabAt</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span>
                            <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="kc">null</span><span class="p">)))</span>
                <span class="k">break</span><span class="p">;</span>                   <span class="c1">// no lock when adding to empty bin
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="c1">// 如果当前不需要初始化表，之前通过 key 定位的 Node 也不为 null，
</span><span class="c1"></span>        <span class="c1">// 则再判断该位置的 Node 是否正在扩容，如果正在扩容，则调用 helpTransfer
</span><span class="c1"></span>        <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">fh</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="na">hash</span><span class="p">)</span> <span class="o">==</span> <span class="n">MOVED</span><span class="p">)</span>
            <span class="n">tab</span> <span class="o">=</span> <span class="n">helpTransfer</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
        <span class="c1">// 当前位置不为空
</span><span class="c1"></span>        <span class="k">else</span> <span class="p">{</span>
            <span class="err">V oldVal </span><span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
            <span class="c1">// 对当前节点加锁
</span><span class="c1"></span>            <span class="kd">synchronized</span> <span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">tabAt</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// 节点是链表的情况
</span><span class="c1"></span>                    <span class="k">if</span> <span class="p">(</span><span class="n">fh</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">binCount</span> <span class="o">=</span> <span class="n">1</span><span class="p">;</span>
                        <span class="c1">// 遍历整个链表
</span><span class="c1"></span>                        <span class="k">for</span> <span class="p">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; e </span><span class="o">=</span> <span class="n">f</span><span class="p">;;</span> <span class="o">++</span><span class="n">binCount</span><span class="p">)</span> <span class="p">{</span>
                            <span class="err">K ek</span><span class="p">;</span>
                            <span class="c1">// 已存在，则替换旧值
</span><span class="c1"></span>                            <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
                                <span class="p">((</span><span class="n">ek</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="na">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span>
                                    <span class="p">(</span><span class="n">ek</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">ek</span><span class="p">))))</span> <span class="p">{</span>
                                <span class="n">oldVal</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="na">val</span><span class="p">;</span>
                                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">onlyIfAbsent</span><span class="p">)</span>
                                    <span class="n">e</span><span class="p">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
                                <span class="k">break</span><span class="p">;</span>
                            <span class="p">}</span>
                            <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; pred </span><span class="o">=</span> <span class="n">e</span><span class="p">;</span>
                            <span class="c1">// 如果是新加入的节点，则通过尾插法将其插入链表
</span><span class="c1"></span>                            <span class="k">if</span> <span class="p">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="na">next</span><span class="p">)</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                                <span class="n">pred</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span>
                                                            <span class="n">value</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>
                                <span class="k">break</span><span class="p">;</span>
                            <span class="p">}</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                    <span class="c1">// 节点是红黑树的情况
</span><span class="c1"></span>                    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="err">f instanceof </span><span class="n">TreeBin</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="err">V&gt; p</span><span class="p">;</span>
                        <span class="n">binCount</span> <span class="o">=</span> <span class="n">2</span><span class="p">;</span>
                        <span class="c1">// 遍历红黑树
</span><span class="c1"></span>                        <span class="k">if</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="p">((</span><span class="n">TreeBin</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;</span><span class="p">)</span><span class="n">f</span><span class="p">).</span><span class="na">putTreeVal</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span>
                                                        <span class="n">value</span><span class="p">))</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
                            <span class="n">oldVal</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="na">val</span><span class="p">;</span>
                            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">onlyIfAbsent</span><span class="p">)</span>
                                <span class="n">p</span><span class="p">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">binCount</span> <span class="o">!=</span> <span class="n">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 链表中的节点个数超过 8，则转成红黑树
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">binCount</span> <span class="o">&gt;=</span> <span class="n">TREEIFY_THRESHOLD</span><span class="p">)</span>
                    <span class="n">treeifyBin</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">oldVal</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">oldVal</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 总结点数加一
</span><span class="c1"></span>    <span class="n">addCount</span><span class="p">(</span><span class="n">1L</span><span class="p">,</span> <span class="n">binCount</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>这里再看一眼 spread() 方法，用于根据 key 的 hashCode 计算 hash 值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">static final int HASH_BITS </span><span class="o">=</span> <span class="n">0x7fffffff</span><span class="p">;</span> 

<span class="err">static final int spread</span><span class="p">(</span><span class="err">int h</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">h</span> <span class="o">^</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">16</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">HASH_BITS</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>put 方法中的注释应该很容易就能看清楚，需要注意一点的是，在 put 方法中的最后 addCount 添加节点时可能会引起扩容（transfer），JDK1.8 的 ConcurrentHashMap 支持并发扩容，之前扩容是由一个线程将旧数组中的键值对转移到新的数组中，支持并发以后，转移的时间就缩短了，但处理逻辑也变复杂了。</p>

<h1 id="参考">参考</h1>

<ul>
<li><a href="https://github.com/openjdk-mirror/jdk7u-jdk/blob/master/src/share/classes/java/util/concurrent/ConcurrentHashMap.java">https://github.com/openjdk-mirror/jdk7u-jdk/blob/master/src/share/classes/java/util/concurrent/ConcurrentHashMap.java</a></li>
<li><a href="https://juejin.im/post/5a2f2f7851882554b837823a">https://juejin.im/post/5a2f2f7851882554b837823a</a></li>
<li><a href="https://www.infoq.cn/article/ConcurrentHashMap">https://www.infoq.cn/article/ConcurrentHashMap</a></li>
<li><a href="https://blog.csdn.net/justloveyou_/article/details/72783008">https://blog.csdn.net/justloveyou_/article/details/72783008</a></li>
<li><a href="https://www.cnblogs.com/ITtangtang/p/3948786.html">https://www.cnblogs.com/ITtangtang/p/3948786.html</a></li>
<li><a href="http://developer.classpath.org/doc/java/util/HashMap-source.html">http://developer.classpath.org/doc/java/util/HashMap-source.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/40327960">https://zhuanlan.zhihu.com/p/40327960</a></li>
<li><a href="https://juejin.im/post/5ca89afa5188257e1d4576ff#heading-0">https://juejin.im/post/5ca89afa5188257e1d4576ff#heading-0</a></li>
<li><a href="https://swenfang.github.io/2018/06/03/Java%208%20ConcurrentHashMap%20%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">https://swenfang.github.io/2018/06/03/Java%208%20ConcurrentHashMap%20%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</a></li>
</ul>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Carol</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2020-03-24
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">Reward</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="https://i.loli.net/2019/11/17/zU4q6LiShYpHrdZ.png">
        <span>wechat</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="https://i.loli.net/2019/11/17/Xnlykx8W3f6DvFi.png">
        <span>alipay</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/Java/">Java</a>
          <a href="/tags/JDK/">JDK</a>
          <a href="/tags/HashMap/">HashMap</a>
          <a href="/tags/ConcurrentHashMap/">ConcurrentHashMap</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/2020/03/31/project-deployment/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">项目部署小结</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/2020/03/21/Serialization-and-Deserialization-in-Java/">
            <span class="next-text nav-default">Java 中的序列化和反序列化</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'SirCarol';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://twitter.com/SirCarol_" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://github.com/dyfloveslife" class="iconfont icon-github" title="github"></a>
  
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Carol</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
