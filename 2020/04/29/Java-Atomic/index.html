<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Java 中的 Atomic 包 - Carol&#39;s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Carol" /><meta name="description" content="为了在多线程并发的情况下能够保证多个线程对数据进行合理的访问，避免出现并发情况下的线程安全问题，Java 从 JDK1.5 开始提供了 java.util.concurrent.atomic 包，它可以通过原子操作类来对某个变量实现更加简单、线程安全的更新操作。
" /><meta name="keywords" content="Java, blog, carol" />






<meta name="generator" content="Hugo 0.85.0 with theme even" />


<link rel="canonical" href="http://localhost:1313/2020/04/29/Java-Atomic/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.a289a5a4.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Java 中的 Atomic 包" />
<meta property="og:description" content="为了在多线程并发的情况下能够保证多个线程对数据进行合理的访问，避免出现并发情况下的线程安全问题，Java 从 JDK1.5 开始提供了 java.util.concurrent.atomic 包，它可以通过原子操作类来对某个变量实现更加简单、线程安全的更新操作。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/2020/04/29/Java-Atomic/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-04-29T15:02:11+08:00" />
<meta property="article:modified_time" content="2020-04-29T19:19:56+08:00" />

<meta itemprop="name" content="Java 中的 Atomic 包">
<meta itemprop="description" content="为了在多线程并发的情况下能够保证多个线程对数据进行合理的访问，避免出现并发情况下的线程安全问题，Java 从 JDK1.5 开始提供了 java.util.concurrent.atomic 包，它可以通过原子操作类来对某个变量实现更加简单、线程安全的更新操作。"><meta itemprop="datePublished" content="2020-04-29T15:02:11+08:00" />
<meta itemprop="dateModified" content="2020-04-29T19:19:56+08:00" />
<meta itemprop="wordCount" content="6320">
<meta itemprop="keywords" content="JVM,Concurrency,Atomic," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java 中的 Atomic 包"/>
<meta name="twitter:description" content="为了在多线程并发的情况下能够保证多个线程对数据进行合理的访问，避免出现并发情况下的线程安全问题，Java 从 JDK1.5 开始提供了 java.util.concurrent.atomic 包，它可以通过原子操作类来对某个变量实现更加简单、线程安全的更新操作。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Carol&#39;s blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Carol&#39;s blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Java 中的 Atomic 包</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-04-29 </span>
        <div class="post-category">
            <a href="/categories/Java/"> Java </a>
            </div>
          <span class="more-meta"> 6320 words </span>
          <span class="more-meta"> 13 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#种类">种类</a></li>
    <li><a href="#基本类型的原子操作">基本类型的原子操作</a></li>
    <li><a href="#数组类型的原子操作">数组类型的原子操作</a></li>
    <li><a href="#引用类型的原子操作">引用类型的原子操作</a>
      <ul>
        <li><a href="#解决-aba-问题">解决 ABA 问题</a></li>
      </ul>
    </li>
    <li><a href="#属性字段类型的原子操作">属性（字段）类型的原子操作</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>为了在多线程并发的情况下能够保证多个线程对数据进行合理的访问，避免出现并发情况下的线程安全问题，Java 从 JDK1.5 开始提供了 java.util.concurrent.atomic 包，它可以通过<code>原子操作类</code>来对某个变量实现更加简单、线程安全的更新操作。</p>
<h1 id="概述">概述</h1>
<p>对于一个比较常见的线程安全问题：多个线程同时对某个对象名为 obj 的成员变量 i 进行自增操作。假设我们使用双核处理器来执行 A、B 两个线程，核 1 执行线程 A，核 2 执行线程 B，这两个线程都需要对变量 i=0 进行加 1 操作。此时就有可能发生 i 的最终结果是 1 而不是 2 的线程安全问题。</p>
<p><strong>为什么会出现 i 的最终结果是 1 的情况</strong>？</p>
<p>这是因为线程 A 先将内存中的变量 i 读取到核 1 中的算数运算单元，然后进行加 1 操作，再将这个计算结果写会到内存中。你可以看到，这个过程不是原子操作，只要线程 B 在线程 A 写回到内存之前，读取了内存中 i 的值（此时为 0），那么就一定会出现 i 的最终结果为 1 的情况。因为线程 A 和线程 B 读取到的 i 值都是 0，分别进行加 1 后的值都是 1，两个线程<strong>先后</strong>将计算结果写回到内存中，就发生了 i 被两次写入的值都是 1 的情况。</p>
<p>从计算机硬件方面讲，如果一段代码被认为是 Atomic（也就是原子的，不可再进行分割的），则表示这段代码在执行的过程中是不能被中断的。通常来说，原子指令由硬件提供，而原子方法则由软件实现。这里的原子方法指的是当某个线程进入到该方法后，不会被中断，而是直到其执行完成。例如，在 x86 平台上，CPU 提供了在指令执行期间对总线加锁的手段。CPU 芯片上有一条引线 <code>#HLOCK pin</code>，如果在汇编指令前添加一个<code>LOCK</code>前缀，则经过汇编以后的机器码就会使 CPU 在执行这条指令的时候把<code>#HLOCK pin</code>的电位拉低，一直持续到这条指令结束的时候才放开，从而把总线锁住，这样同一总线上的 CPU 就暂时不能通过总线访问内存了，这样就保证了这条指令在多处理器环境中的原子性。</p>
<p>对于以上这种线程不安全的更新操作，通常我们会使用 synchronized 将对象 obj 进行加锁来解决这个问题，但 synchronized 采用的是悲观锁的策略，并不是一种高效的手段。Java 在 JDK1.5 及其以后提供了 java.util.concurrent.atomic 包，供我们以一种简单、高效的方式来实现对变量进行更新的线程安全的操作。</p>
<p>java.util.concurrent.atomic 包提供了不同类型的原子更新方式，都采用的是以乐观锁的策略进行更新数据，其核心是 <strong>CAS</strong>操作。因此，在分析 Atomic 包之前，需要知道 Java 中 CAS 的概念。</p>
<h1 id="cas">CAS</h1>
<p>多个线程在修改某一变量的时候需要加锁，加锁之后再进行修改，这样可以保证数据的正确性。如果想要在不上锁的情况下达到这种效果，则可以使用 CAS，即 Compare and Swap，底层使用汇编指令 CMPXCHG 实现。该指令有三个需要操作数：变量的内存值 V（value）、变量的当前预期值E（exception）以及变量想要更新的值U（update），当且仅当预期值 E 和内存值 V 相等时，将内存值 V 修改为想要更新的值 U 并返回 true，否则什么都不做返回 false。</p>
<p>我们可以利用 CAS 操作来解决上述变量自增遇到的问题，线程 A 将内存中的变量 i=0 读到一个临时变量中，然后再将 i 读取到核 1 的算术运算单元中，接下来进行加 1 操作，<strong>比较临时变量中的值和 i 当前的值是否相同，如果相同则用运算单元中的运算结果 1 覆盖内存中的 i 值（此过程属于原子操作，不能被中断并且其他线程中的 CAS 操作不能同时执行）</strong>，否则执行失败。如果执行失败的话，说明另外一个线程 B 已经将 i 的值进行了修改。</p>
<p>因此可以看到，如果两个线程一开始读取 i 的都是 0，那么只能有一个线程的 CAS 操作能成功，因为 CAS 操作不能并发执行。对 CAS 操作执行失败的线程，只需要通过<code>自旋（循环）</code>操作，那么就一定会执行成功。注意到此过程没有发生阻塞。</p>
<p><strong>如何理解<code>自旋</code>操作</strong>？</p>
<p>假设线程 A 要对数值 0 进行自增操作：</p>
<ul>
<li>首先线程 A 会拿到 0 这个值，然后进行加 1 操作，得到结果值为 1；</li>
<li>在写回内存的时候（也就是在覆盖原值的时候）需要判断原始的 0 值和我最开始拿到的 0 值是否是相同的：
<ul>
<li>如果相同，则说明没有其它线程对 0 值进行修改过，则线程 A 会将修改后的 1 进行写回操作；</li>
<li>如果不相同，则说明其它线程已经对 0 值进行修改过了，假设修改成了 1，则线程 A 此时需要再次获取 1 这个值，再进行自增操作变成 2，然后还需要比较之前的 1 是否和线程 A 拿到的 1 相等：
<ul>
<li>如果相等，则将计算后的结果 2 写回；</li>
<li>如果不相等，则说明有其它的线程已经修改过了，则还需要再次获取值。</li>
</ul>
</li>
</ul>
</li>
<li>因此这是一个不断<strong>自旋</strong>的操作，只要之前的值和当前读取到的值不相等，就一直自旋，具体可以通过 while 循环进行不断的自旋。</li>
</ul>
<p><strong>但需要注意的是，CAS 会面临以下三个问题</strong>：</p>
<ul>
<li><strong>ABA 问题</strong>。如果一个值原来是 A，由于某些原因，变成了 B，结果又变成了 A。那么使用 CAS 在检查时会发现它没有发生变化，但实际上已经发生了变化。也就是说，其它线程修改多次以后，最后得到的值和原始值相同，那么线程 A 就会认为这个值没有被修改过，但事实上已经被修改过了，只是线程 A 看不到而已。</li>
<li><strong>循环时间长开销大</strong>。自旋 CAS 如果长时间不成功，则会给 CPU 带来很大的执行开销。</li>
<li><strong>只能保证一个共享变量的原子操作</strong>。当只有一个共享变量的时候，使用 CAS 来保证原子操作是没有问题的。而如果对多个共享变量进行操作时，则无法保证操作的原子性。</li>
</ul>
<p>对于如何 ABA 问题，可以给原始值添加一个版本号，每次变量更新的时候就会增加，例如 A-&gt;B-&gt;C 会变成 1A-&gt;2B-&gt;3C。当然，也可以加时间戳。此外，还可以通过 Atomic 包下的 AtomicStampedReference 中的 compareAndSet 方法来解决 ABA 问题。</p>
<h1 id="atomic">Atomic</h1>
<p>Atomic 包下的类所实现的功能就是在多线程环境下，当有多个线程同时对的变量进行操作时，具有排他性，即当多个线程同时对某变量进行修改的时候，仅有一个线程会成功，未成功的线程可以通过自旋操作不断尝试，直到成功为止。</p>
<p>由于变量的类型有很多，例如基本类型和引用类型，因此 Atomic 包下大体可以分为 4 种类型的原子更新方式，即对<code>基本类型</code>进行原子更新、对<code>数组</code>进行原子更新、对<code>引用类型</code>进行原子更新以及对<code>属性（字段）</code>进行原子更新。</p>
<p>需要注意的是，Atomic 包下的类基本都是使用的 Unsafe 实现的包装类。即 Atomic 包下的类中的核心方法会调用 Unsafe 类中的几个本地（native）方法。sun.misc.Unsafe 包含了大量的对 C 代码的操作，包括直接对内存进行操作以及原子操作的调用。称之为 Unsafe 是因为对该类中的方法进行调用会发生安全隐患，需要小心使用，有可能会遇到类似于 C++ 中的指针越界等问题。</p>
<p>Java 无法直接访问底层操作系统，而是通过本地方法（native）来访问。Unsafe 提供了硬件级别的操作，例如获取某个属性在内存中的位置，或者修改对象的字段值，只不过平时很少用到。</p>
<p>Atomic 包提供的类如下图所示：</p>
<!-- raw HTML omitted -->
<h2 id="种类">种类</h2>
<p>按照不同的类型，可分为如下 4 类：</p>
<ul>
<li>对基本类型进行原子操作：
<ul>
<li>AtomicBoolean</li>
<li>AtomicInteger</li>
<li>AtomicLong</li>
</ul>
</li>
<li>对数组进行原子操作：这里操作的表示数组，而是数组中的每个元素。
<ul>
<li>AtomicIntegerArray</li>
<li>AtomicLongArray</li>
<li>AtomicReferenceArray</li>
</ul>
</li>
<li>对引用类型进行原子操作：
<ul>
<li>AtomicReference</li>
<li>AtomicMarkableReference</li>
<li>AtomicStampedReference</li>
</ul>
</li>
<li>对属性（字段）类型进行原子操作：
<ul>
<li>AtomicIntegerFieldUpdater</li>
<li>AtomicLongFieldUpdater</li>
<li>AtomicReferenceFieldUpdater</li>
</ul>
</li>
</ul>
<p>对于常用的 AtomicInteger、AtomicReference 以及 AtomicStampedReference，这里以 AtomicInteger 为例，介绍该类中的几个方法。</p>
<blockquote>
<p>需要注意的是：JDK1.7 中 AtomicInteger 下的多个方法与 JDK1.8 中的多个方法的实现方式是不同的，这里以 JDK1.8 为例。</p>
</blockquote>
<h2 id="基本类型的原子操作">基本类型的原子操作</h2>
<p>先来看 AtomicInteger 的<strong>构造方法</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>

<span class="kd">public</span> <span class="nf">AtomicInteger</span><span class="o">()</span> <span class="o">{</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nf">AtomicInteger</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialValue</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">initialValue</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果在初始化的时候指定了参数 initialValue，则会将该参数保存在被 volatile 修饰的 value 里，volatile 可以保证一个线程的修改能够被其它线程所看到，即内存的可见性。</p>
<p><strong>addAndGet(int delta)</strong> 方法使用原子的方式将输入的值 delta 与上述的 value 值进行相加，并返回结果，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">addAndGet</span><span class="o">(</span><span class="kt">int</span> <span class="n">delta</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">getAndAddInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">valueOffset</span><span class="o">,</span> <span class="n">delta</span><span class="o">)</span> <span class="o">+</span> <span class="n">delta</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>compareAndSet(int expect, int update)</strong> 属于 CAS 最核心的操作，如果当前值等于预期值，则以原子的方式将该值设置为给定的更新值，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">compareAndSet</span><span class="o">(</span><span class="kt">int</span> <span class="n">expect</span><span class="o">,</span> <span class="kt">int</span> <span class="n">update</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">valueOffset</span><span class="o">,</span> <span class="n">expect</span><span class="o">,</span> <span class="n">update</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>getAndIncrement()</strong> 方法以原子的方式将当前值加 1。需要注意的是该方法返回的是之前的值。如果想要返回更新后的值，可以使用<strong>incrementAndGet()</strong> 方法，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getAndIncrement</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">getAndAddInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">valueOffset</span><span class="o">,</span> <span class="n">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">incrementAndGet</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">getAndAddInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">valueOffset</span><span class="o">,</span> <span class="n">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>下面就是一个简单的示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AtomicIntegerTest</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">AtomicInteger</span> <span class="n">atomicInteger</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicInteger</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">atomicInteger</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">atomicInteger</span><span class="o">.</span><span class="na">getAndIncrement</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">atomicInteger</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">atomicInteger</span><span class="o">.</span><span class="na">incrementAndGet</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>输出结果如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">1</span>
<span class="n">1</span>
<span class="n">2</span>
<span class="n">3</span>
</code></pre></td></tr></table>
</div>
</div><p>get() 方法返回当前的值，因为初始化的时候设置的值为 1，因此 get() 方法返回 1；getAndIncrement() 方法对 1 进行了自增操作，因此 value 是 2，但该方法返回的是之前的值，即 1；这里又一次调用了 get() 方法，因此返回的是 2；最后调用了 incrementAndGet() 方法，该方法对 2 进行了自增操作，然后返回的是更新后的值，也就是 3。</p>
<p>这里以 getAndIncrement() 的源码为例，来理解整个 CAS 的过程，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// AtomicInteger.java
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getAndIncrement</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">getAndAddInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">valueOffset</span><span class="o">,</span> <span class="n">1</span><span class="o">);</span>
<span class="o">}</span>


<span class="c1">// Unsafe.class
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getAndAddInt</span><span class="o">(</span><span class="n">Object</span> <span class="n">var1</span><span class="o">,</span> <span class="kt">long</span> <span class="n">var2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">var4</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">var5</span><span class="o">;</span>
    <span class="k">do</span> <span class="o">{</span>
        <span class="n">var5</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getIntVolatile</span><span class="o">(</span><span class="n">var1</span><span class="o">,</span> <span class="n">var2</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">while</span><span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="n">var1</span><span class="o">,</span> <span class="n">var2</span><span class="o">,</span> <span class="n">var5</span><span class="o">,</span> <span class="n">var5</span> <span class="o">+</span> <span class="n">var4</span><span class="o">));</span>

    <span class="k">return</span> <span class="n">var5</span><span class="o">;</span>
<span class="o">}</span>


<span class="c1">// Unsafe.class
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">native</span> <span class="kt">int</span> <span class="nf">getIntVolatile</span><span class="o">(</span><span class="n">Object</span> <span class="n">var1</span><span class="o">,</span> <span class="kt">long</span> <span class="n">var2</span><span class="o">);</span>


<span class="c1">// Unsafe.class
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="kt">boolean</span> <span class="nf">compareAndSwapInt</span><span class="o">(</span><span class="n">Object</span> <span class="n">var1</span><span class="o">,</span> <span class="kt">long</span> <span class="n">var2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">var4</span><span class="o">,</span> <span class="kt">int</span> <span class="n">var5</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><p>在 JDK1.8 下，调用 AtomicInteger 类下的 getAndIncrement() 方法，实际调用的是 Unsafe 类下的 getAndAddInt(Object var1, long var2, int var4) 方法。因此这里的 var1 表示当前对象 this，var2 表示共享变量在当前对象上的内存偏移量，var4 表示传递过来的值是 1。</p>
<p>在 getAndAddInt(Object var1, long var2, int var4) 方法中，首先定义了 var5 表示期望的值，然后通过 do-while 直到更新成功才跳出循环。在 do{ } 中通过 getIntVolatile() 方法获取 value 的最新值。在 while() 中，var5 + var4 表示需要更新的值，如果 compareAndSwapInt() 方法返回 false，说明 value 值被其它线程修改了，于是就循环重试，再次获取最新值，再次计算需要跟新的值 var5 + var4，直到更新成功。</p>
<p>这里使用了 var1、var2、var3、var4、var5，看起来不是很直观，现将其修改如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getAndAddInt</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">,</span> <span class="kt">long</span> <span class="n">valueOffset</span><span class="o">,</span> <span class="kt">int</span> <span class="n">var</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">expect</span><span class="o">;</span>
    <span class="k">do</span> <span class="o">{</span>
        <span class="n">expect</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getIntVolatile</span><span class="o">(</span><span class="n">obj</span><span class="o">,</span> <span class="n">valueOffset</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">while</span><span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="n">obj</span><span class="o">,</span> <span class="n">valueOffset</span><span class="o">,</span> <span class="n">expect</span><span class="o">,</span> <span class="n">expect</span> <span class="o">+</span> <span class="n">var</span><span class="o">));</span>

    <span class="k">return</span> <span class="n">expect</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="数组类型的原子操作">数组类型的原子操作</h2>
<p>以 AtomicIntegerArray 为例，该类型是对数组中的每个元素以原子的方式进行更新。先看它的构造方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">;</span>

<span class="kd">public</span> <span class="nf">AtomicIntegerArray</span><span class="o">(</span><span class="kt">int</span> <span class="n">length</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">length</span><span class="o">];</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nf">AtomicIntegerArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在初始化的时候，可以指定数组的长度，也可以传入一个指定的数组。需要注意的是，后面的这种方式会将数组复制一份，因此当 AtomicIntegerArray 对数组中的元素进行修改时，不会影响传入的数组。</p>
<p>下面看常用的方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">addAndGet</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">delta</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">getAndAdd</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">delta</span><span class="o">)</span> <span class="o">+</span> <span class="n">delta</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">getAndAdd</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">delta</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">getAndAddInt</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="n">checkedByteOffset</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">delta</span><span class="o">);</span>
<span class="o">}</span>

</code></pre></td></tr></table>
</div>
</div><p>addAndGet() 方法表示以原子的方式将给定的值与索引为 i 的值进行相加，<strong>返回更新后的值</strong>。而 getAndAdd() 方法作用和 addAndGet() 方法是一样的，但不同的是，getAndAdd() 方法<strong>返回更新前的值</strong>。</p>
<p>而下面的 compareAndSet() 方法表示如果当前值等于预期值，则以原子的方式将数组位置 i 的元素设置成 update 值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">compareAndSet</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">expect</span><span class="o">,</span> <span class="kt">int</span> <span class="n">update</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">compareAndSetRaw</span><span class="o">(</span><span class="n">checkedByteOffset</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">expect</span><span class="o">,</span> <span class="n">update</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">compareAndSetRaw</span><span class="o">(</span><span class="kt">long</span> <span class="n">offset</span><span class="o">,</span> <span class="kt">int</span> <span class="n">expect</span><span class="o">,</span> <span class="kt">int</span> <span class="n">update</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">unsafe</span><span class="o">.</span><span class="na">compareAndSwapInt</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="n">offset</span><span class="o">,</span> <span class="n">expect</span><span class="o">,</span> <span class="n">update</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>下面通过一个示例进行说明：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AtomicIntegerArrayTest</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="n">AtomicIntegerArray</span> <span class="n">ai</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicIntegerArray</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">1</span><span class="o">,</span> <span class="n">2</span><span class="o">,</span> <span class="n">3</span><span class="o">});</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ai</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">0</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ai</span><span class="o">.</span><span class="na">addAndGet</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">5</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;--&#34;</span><span class="o">);</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ai</span><span class="o">.</span><span class="na">getAndAdd</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="n">5</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ai</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">1</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;--&#34;</span><span class="o">);</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ai</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">2</span><span class="o">,</span> <span class="n">10</span><span class="o">,</span> <span class="n">30</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ai</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">2</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&#34;--&#34;</span><span class="o">);</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ai</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">2</span><span class="o">,</span> <span class="n">3</span><span class="o">,</span> <span class="n">30</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ai</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">2</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>输出结果如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">1</span>
<span class="n">6</span>
<span class="o">--</span>
<span class="n">2</span>
<span class="n">7</span>
<span class="o">--</span>
<span class="kc">false</span>
<span class="n">3</span>
<span class="o">--</span>
<span class="kc">true</span>
<span class="n">30</span>
</code></pre></td></tr></table>
</div>
</div><p>这里一共分为 4 个部分：</p>
<ul>
<li>第一部分：
<ul>
<li>首先获取数组索引为 0 的元素，因此输出 1；</li>
<li>然后将索引为 0 的元素与 5 相加，返回更新后的值，因此输出 6。</li>
</ul>
</li>
<li>第二部分：
<ul>
<li>首先将数组索引为 1 的元素与 5 相加，由于 getAndAdd() 方法返回更新前的值，因此输出 2；</li>
<li>然后获取数组索引为 1 的元素，因此输出 7。</li>
</ul>
</li>
<li>第三部分：
<ul>
<li>首先进行更新操作，这里想要将索引为 2 的元素 3 更新成 30，但由于期望值 10 与之前位置上的 3 不相等，因此返回 false；</li>
<li>然后通过查看索引为 2 的元素可以看到，该位置上的元素还是 3，没有被更新成功。</li>
</ul>
</li>
<li>第四部分：
<ul>
<li>首先也是进行更新操作，这里也是想要将索引为 2 的元素 3 更新成 30，由于期望值 3 与 之前的位置上的 3 相等，因此返回 true；</li>
<li>然后通过查看索引为 2 的元素可以看到，该位置上的元素为 30，说明更新成功。</li>
</ul>
</li>
</ul>
<h2 id="引用类型的原子操作">引用类型的原子操作</h2>
<p>这里以 AtomicReference 为例，首先看一下它的构造方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">volatile</span> <span class="n">V</span> <span class="n">value</span><span class="o">;</span>

<span class="kd">public</span> <span class="nf">AtomicReference</span><span class="o">(</span><span class="n">V</span> <span class="n">initialValue</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">initialValue</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nf">AtomicReference</span><span class="o">()</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在创建对象的时候，可以给 AtomicReference 传入一个值，该值将会赋值给被 volatile 修饰的 value，以供其它的方法（如 get()、set() 等）使用。</p>
<p>下面的 get()、set() 方法也很简单：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="n">V</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">V</span> <span class="n">newValue</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">newValue</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>接下来通过一个示例说明如何以原子的方式更新引用类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AtomicReferenceTest</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="n">AtomicReference</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">ar</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicReference</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="n">User</span> <span class="n">user</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User</span><span class="o">(</span><span class="s">&#34;zhangsan&#34;</span><span class="o">,</span> <span class="n">25</span><span class="o">);</span>
        <span class="n">ar</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>

        <span class="n">User</span> <span class="n">updateUser</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User</span><span class="o">(</span><span class="s">&#34;lisi&#34;</span><span class="o">,</span> <span class="n">30</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ar</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">updateUser</span><span class="o">));</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ar</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ar</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">getAge</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">age</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>输出结果如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">true
lisi
30
</code></pre></td></tr></table>
</div>
</div><p>首先定义了一个内部类 User，并定义了两个字段 name 和 age，给出了 getter() 方法。然后创建了一个 user 对象 (&ldquo;zhangsan&rdquo;, 25)，并通过 set() 方法将该对象设置到了 AtomicReference 中。最后调用了 compareAndSet() 方法进行了原子更新操作，实现的原理和 AtomicInteger 中的 compareAndSet() 方法相同。</p>
<p>如果将<code>ar.set(user);</code>语句进行注释，则 compareAndSet() 方法会返回 false，因为 AtomicReference 中的 value 没有被设置任务值，当通过 compareAndSet() 进行比较的时候，当前值不等于预期值，因此将会返回 false。</p>
<h3 id="解决-aba-问题">解决 ABA 问题</h3>
<p>这里可以使用 AtomicStampedReference 来解决 ABA 问题，<!-- raw HTML omitted -->它在实现 compareAndSet() 方法的时候除了要比较当前对象的值和预期值以外，还需要比较当前的戳值和预期戳值，只有全部相同时，CAS 才能操作成功。<!-- raw HTML omitted -->每次更新的时候，戳值都会发生变化，我们可以自己设置该戳值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">compareAndSet</span><span class="o">(</span><span class="n">V</span> <span class="n">expectedReference</span><span class="o">,</span> <span class="n">V</span> <span class="n">newReference</span><span class="o">,</span> <span class="kt">int</span> <span class="n">expectedStamp</span><span class="o">,</span> <span class="kt">int</span> <span class="n">newStamp</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Pair</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">current</span> <span class="o">=</span> <span class="n">pair</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">expectedReference</span> <span class="o">==</span> <span class="n">current</span><span class="o">.</span><span class="na">reference</span> <span class="o">&amp;&amp;</span>
            <span class="n">expectedStamp</span> <span class="o">==</span> <span class="n">current</span><span class="o">.</span><span class="na">stamp</span> <span class="o">&amp;&amp;</span>
            <span class="o">((</span><span class="n">newReference</span> <span class="o">==</span> <span class="n">current</span><span class="o">.</span><span class="na">reference</span> <span class="o">&amp;&amp;</span>
            <span class="n">newStamp</span> <span class="o">==</span> <span class="n">current</span><span class="o">.</span><span class="na">stamp</span><span class="o">)</span> <span class="o">||</span> <span class="n">casPair</span><span class="o">(</span><span class="n">current</span><span class="o">,</span> <span class="n">Pair</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">newReference</span><span class="o">,</span> <span class="n">newStamp</span><span class="o">)));</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>以上就是使用 AtomicStampedReference 来解决 ABA 问题的主要方法，但是你会发现，这里的 Pair 又是什么呢？这里的 Pair 其实是 AtomicStampedReference 的一个内部类，它将元素值和版本号绑定在了一起，存储在 Pair 的 reference 和 stamp 中，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">T</span> <span class="n">reference</span><span class="o">;</span>
    <span class="kd">final</span> <span class="kt">int</span> <span class="n">stamp</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nf">Pair</span><span class="o">(</span><span class="n">T</span> <span class="n">reference</span><span class="o">,</span> <span class="kt">int</span> <span class="n">stamp</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">reference</span> <span class="o">=</span> <span class="n">reference</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">stamp</span> <span class="o">=</span> <span class="n">stamp</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Pair</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">of</span><span class="o">(</span><span class="n">T</span> <span class="n">reference</span><span class="o">,</span> <span class="kt">int</span> <span class="n">stamp</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Pair</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;(</span><span class="n">reference</span><span class="o">,</span> <span class="n">stamp</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当了解了内部类 Pair 之后，现在我们看一下 compareAndSet() 方法到底是如何执行的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">compareAndSet</span><span class="o">(</span><span class="n">V</span> <span class="n">expectedReference</span><span class="o">,</span> <span class="n">V</span> <span class="n">newReference</span><span class="o">,</span> <span class="kt">int</span> <span class="n">expectedStamp</span><span class="o">,</span> <span class="kt">int</span> <span class="n">newStamp</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 获取当前的（元素值，版本号）对
</span><span class="c1"></span>    <span class="n">Pair</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">current</span> <span class="o">=</span> <span class="n">pair</span><span class="o">;</span>
    <span class="k">return</span>
            <span class="c1">// 如果引用没有变
</span><span class="c1"></span>            <span class="n">expectedReference</span> <span class="o">==</span> <span class="n">current</span><span class="o">.</span><span class="na">reference</span> <span class="o">&amp;&amp;</span>
            <span class="c1">// 如果版本号也没有变
</span><span class="c1"></span>            <span class="n">expectedStamp</span> <span class="o">==</span> <span class="n">current</span><span class="o">.</span><span class="na">stamp</span> <span class="o">&amp;&amp;</span>
            <span class="c1">// 如果新的引用等于旧的引用
</span><span class="c1"></span>            <span class="o">((</span><span class="n">newReference</span> <span class="o">==</span> <span class="n">current</span><span class="o">.</span><span class="na">reference</span> <span class="o">&amp;&amp;</span>
            <span class="c1">// 如果新的时间戳等于旧的时间戳
</span><span class="c1"></span>            <span class="n">newStamp</span> <span class="o">==</span> <span class="n">current</span><span class="o">.</span><span class="na">stamp</span><span class="o">)</span> <span class="o">||</span> 
            <span class="c1">// 构造新的 Pair 对象并使用 CAS 的方式更新
</span><span class="c1"></span>            <span class="n">casPair</span><span class="o">(</span><span class="n">current</span><span class="o">,</span> <span class="n">Pair</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">newReference</span><span class="o">,</span> <span class="n">newStamp</span><span class="o">)));</span>
<span class="o">}</span>


<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">casPair</span><span class="o">(</span><span class="n">Pair</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">cmp</span><span class="o">,</span> <span class="n">Pair</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 调用 Unsafe 中的 compareAndSwapObject 方法通过 CAS 的方式更新 Pair 的引用为新的引用
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">pairOffset</span><span class="o">,</span> <span class="n">cmp</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>因此，总体的流程为：</p>
<ul>
<li>如果元素值和版本号都没有发生变化，并且和新的也相同，那么返回 true；</li>
<li>如果元素值和版本号都没有发生变化，并且和新的不完全相同，那么就构造一个新的 Pair 对象并通过 CAS 的方式更新 Pair。</li>
</ul>
<p>当然也可以使用 AtomicMarkableReference，它的内部存储方式也是使用了一个内部类 Pair，但与 AtomicStampedReference 不同的是，AtomicMarkableReference 维护的不是一个版本号，而是维护一个 boolean 类型的标记 mark，根据这个标记 mark 是否修改过，来解决 ABA 问题。</p>
<h2 id="属性字段类型的原子操作">属性（字段）类型的原子操作</h2>
<p>这里以 AtomicIntegerFieldUpdater 为例，它属于以原子的方式更新整型字段的更新器。要想原子的更新字段类，首先由于原子更新类都是抽象类，因此使用的时候必须使用静态方法 newUpdater() 创建一个更新器，并且需要设置想要更新的类和属性，然后在更新类的字段或属性的时候需要使用 public volatile 进行修饰。如以下示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AtomicIntegerFieldUpdaterTest</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="n">AtomicIntegerFieldUpdater</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">atomicIntegerFieldUpdater</span> <span class="o">=</span> 
                    <span class="n">AtomicIntegerFieldUpdater</span><span class="o">.</span><span class="na">newUpdater</span><span class="o">(</span><span class="n">User</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">&#34;age&#34;</span><span class="o">);</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">User</span> <span class="n">user</span> <span class="o">=</span> <span class="k">new</span> <span class="n">User</span><span class="o">(</span><span class="s">&#34;zhangsan&#34;</span><span class="o">,</span> <span class="n">25</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">atomicIntegerFieldUpdater</span><span class="o">.</span><span class="na">getAndIncrement</span><span class="o">(</span><span class="n">user</span><span class="o">));</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">atomicIntegerFieldUpdater</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">user</span><span class="o">));</span>
    <span class="o">}</span>


    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
        <span class="c1">// 注意这里需要使用 public volatile 修饰 age
</span><span class="c1"></span>        <span class="kd">public</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">age</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>输出结果如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">25
26
</code></pre></td></tr></table>
</div>
</div><p>首先创建了用于原子操作的更新器 AtomicIntegerFieldUpdater，并指明了需要更新的对象类以及对象的属性，这里指定属性<code>age</code>作为需要更新的属性，但前提是需要在 User 类中将 age 属性使用 public volatile 修饰。然后通过 getAndIncrement() 方法将 age 字段进行加 1 操作，但需要注意的是，该方法返回的是更新之前的值，即 25，最后通过调用 get() 方法给定对象的当前 age 的值，也就是更新后的值，即 26。</p>
<p>这里的 getAndIncrement() 方法也是通过 CAS 进行不断的自旋进行操作的，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAndIncrement</span><span class="o">(</span><span class="n">T</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">prev</span><span class="o">,</span> <span class="n">next</span><span class="o">;</span>
    <span class="k">do</span> <span class="o">{</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">get</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
        <span class="n">next</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">while</span> <span class="o">(!</span><span class="n">compareAndSet</span><span class="o">(</span><span class="n">obj</span><span class="o">,</span> <span class="n">prev</span><span class="o">,</span> <span class="n">next</span><span class="o">));</span>
    <span class="k">return</span> <span class="n">prev</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">(</span><span class="n">T</span> <span class="n">obj</span><span class="o">);</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="参考">参考</h1>
<ul>
<li><a href="https://book.douban.com/subject/26591326/">https://book.douban.com/subject/26591326/</a></li>
<li><a href="https://www.cnblogs.com/nullzx/p/4967931.html">https://www.cnblogs.com/nullzx/p/4967931.html</a></li>
<li><a href="https://juejin.im/post/5aeec351518825670a103292">https://juejin.im/post/5aeec351518825670a103292</a></li>
</ul>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Carol</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2020-04-29
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">Reward</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="https://i.loli.net/2019/11/17/zU4q6LiShYpHrdZ.png">
        <span>wechat</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="https://i.loli.net/2019/11/17/Xnlykx8W3f6DvFi.png">
        <span>alipay</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/JVM/">JVM</a>
          <a href="/tags/Concurrency/">Concurrency</a>
          <a href="/tags/Atomic/">Atomic</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/2020/05/01/Java-AQS/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Java 中的 AQS</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/2020/04/27/Java-CopyOnWrite/">
            <span class="next-text nav-default">Java 中的 CopyOnWrite 容器</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'SirCarol';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://twitter.com/SirCarol_" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://github.com/dyfloveslife" class="iconfont icon-github" title="github"></a>
  
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Carol</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
