<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Java 中的 AQS - Carol&#39;s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Carol" /><meta name="description" content="之前的《Java 中的 Lock 及各种锁的概念》简单介绍了 Lock 的使用以及 Lock 的唯一实现类 ReentrantLock 中的方法。我们一般会拿 synchronized 和 ReentrantLock 做比较。而在了解 ReentrantLock 之前需要理解 AQS 的实现。因此，本文分析了 AQS 中主要的源码，包括独占模式与共享模式，为更好的认识 ReentrantLock 打下基础。
" /><meta name="keywords" content="Java, blog, carol" />






<meta name="generator" content="Hugo 0.59.1 with theme even" />


<link rel="canonical" href="http://localhost:1313/2020/05/01/Java-AQS/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link href="/dist/even.a289a5a4.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Java 中的 AQS" />
<meta property="og:description" content="之前的《Java 中的 Lock 及各种锁的概念》简单介绍了 Lock 的使用以及 Lock 的唯一实现类 ReentrantLock 中的方法。我们一般会拿 synchronized 和 ReentrantLock 做比较。而在了解 ReentrantLock 之前需要理解 AQS 的实现。因此，本文分析了 AQS 中主要的源码，包括独占模式与共享模式，为更好的认识 ReentrantLock 打下基础。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/2020/05/01/Java-AQS/" />
<meta property="article:published_time" content="2020-05-01T11:35:11+08:00" />
<meta property="article:modified_time" content="2020-05-01T14:36:11+08:00" />
<meta itemprop="name" content="Java 中的 AQS">
<meta itemprop="description" content="之前的《Java 中的 Lock 及各种锁的概念》简单介绍了 Lock 的使用以及 Lock 的唯一实现类 ReentrantLock 中的方法。我们一般会拿 synchronized 和 ReentrantLock 做比较。而在了解 ReentrantLock 之前需要理解 AQS 的实现。因此，本文分析了 AQS 中主要的源码，包括独占模式与共享模式，为更好的认识 ReentrantLock 打下基础。">


<meta itemprop="datePublished" content="2020-05-01T11:35:11&#43;08:00" />
<meta itemprop="dateModified" content="2020-05-01T14:36:11&#43;08:00" />
<meta itemprop="wordCount" content="9676">



<meta itemprop="keywords" content="Java,Concurrent,AbstractQueuedSynchronizer,Lock," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java 中的 AQS"/>
<meta name="twitter:description" content="之前的《Java 中的 Lock 及各种锁的概念》简单介绍了 Lock 的使用以及 Lock 的唯一实现类 ReentrantLock 中的方法。我们一般会拿 synchronized 和 ReentrantLock 做比较。而在了解 ReentrantLock 之前需要理解 AQS 的实现。因此，本文分析了 AQS 中主要的源码，包括独占模式与共享模式，为更好的认识 ReentrantLock 打下基础。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Carol&#39;s blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Writing</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/2020/01/12/post_summary/">
        <li class="mobile-menu-item">❤文章汇总</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Carol&#39;s blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Writing</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/2020/01/12/post_summary/">❤文章汇总</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Java 中的 AQS</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-05-01 </span>
        <div class="post-category">
            <a href="/categories/Java/"> Java </a>
            </div>
          <span class="more-meta"> 9676 words </span>
          <span class="more-meta"> 20 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#概述">概述</a></li>
<li><a href="#队列锁">队列锁</a>
<ul>
<li><a href="#概念">概念</a></li>
<li><a href="#自旋和阻塞">自旋和阻塞</a></li>
<li><a href="#clh">CLH</a></li>
</ul></li>
<li><a href="#aqs">AQS</a>
<ul>
<li><a href="#waitstatus">waitStatus</a></li>
<li><a href="#acquire-int-arg">acquire(int arg)</a>
<ul>
<li><a href="#tryacquire-int-arg">tryAcquire(int arg)</a></li>
<li><a href="#addwaiter-node-mode">addWaiter(Node mode)</a></li>
<li><a href="#acquirequeued-final-node-node-int-arg">acquireQueued(final Node node, int arg)</a></li>
</ul></li>
<li><a href="#release-int-arg">release(int arg)</a>
<ul>
<li><a href="#tryrelease-int-arg">tryRelease(int arg)</a></li>
<li><a href="#unparksuccessor-node-node">unparkSuccessor(Node node)</a></li>
</ul></li>
<li><a href="#acquireshared-int-arg">acquireShared(int arg)</a>
<ul>
<li><a href="#doacquireshared-int-arg">doAcquireShared(int arg)</a></li>
<li><a href="#setheadandpropagate-node-node-int-propagate">setHeadAndPropagate(Node node, int propagate)</a></li>
</ul></li>
<li><a href="#releaseshared-int-arg">releaseShared(int arg)</a>
<ul>
<li><a href="#doreleaseshared">doReleaseShared()</a></li>
</ul></li>
</ul></li>
<li><a href="#小结">小结</a></li>
<li><a href="#参考">参考</a></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>之前的<a href="https://dyfloveslife.github.io/2020/04/05/Java-Lock/">《Java 中的 Lock 及各种锁的概念》</a>简单介绍了 Lock 的使用以及 Lock 的唯一实现类 ReentrantLock 中的方法。我们一般会拿 <a href="https://dyfloveslife.github.io/2020/04/05/Java-Synchronized/">synchronized</a> 和 ReentrantLock 做比较。而在了解 ReentrantLock 之前需要理解 AQS 的实现。因此，本文分析了 AQS 中主要的源码，包括独占模式与共享模式，为更好的认识 ReentrantLock 打下基础。</p>

<h1 id="概述">概述</h1>

<p>ReentrantLock 是基于 AQS 实现的，而 AQS 又是基于 CAS 实现的。因此，最好先熟悉一下 CAS 的实现原理，对于这点我在<a href="https://dyfloveslife.github.io/2020/04/29/Java-Atomic/#cas">《Java 中的 Atomic 包》</a>中提到过。这样的话，接下来应该介绍的是 AQS（AbstractQueuedSynchronizer，即抽象的队列式的同步器），其内部的结构是基于<code>队列锁</code>实现的。因此，还需要提前介绍一下队列锁相关的内容。</p>

<p><strong>我在准备起笔 AQS 文章时，在网上搜集了许多相关的文章，绝大部分都是直奔主题，直接从 AQS 讲起。这样直接讲的话会缺少必要的背景知识，看过文章之后使读者不清楚 AQS 的来龙去脉。我在这里一方面是抛砖引玉，另一方面是尽量保证 AQS 介绍的完整性。因此，本文的总体目录结构如下所示</strong>：</p>

<ul>
<li>队列锁（Queue Lock）</li>
<li>CAS（Compare and Swap，比较且交换）</li>
<li>AQS</li>
</ul>

<p>需要提及的是，CAS 已经在<a href="https://dyfloveslife.github.io/2020/04/29/Java-Atomic/#cas">《Java 中的 Atomic 包》</a>中提到过，包括它的概念以及需要注意的问题，当然我也会在本文中提到 CAS。</p>

<h1 id="队列锁">队列锁</h1>

<h2 id="概念">概念</h2>

<p>这里所说的队列锁属于<code>互斥算法（Mutual exclusion algorithms）</code>的一种，<code>互斥算法</code>可以用来对共享内存进行读、修改、写操作。而在多处理器的环境下，现代共享内存多处理器提供了比读写更强的操作。例如所谓的“原子”操作 CAS，假如内存中有一个变量 i 的值为 0，当处理器想要对 i 进行加 1 操作的时候，该处理器首先会将内存中的 0 读到算数运算单元，然后将其加 1 后变成 1。在写回到内存之前，处理器需要判断之前首次读进算数运算单元的值与内存中的值是否相等，由于之前首次读进算数运算单元的值为 0 并且内存中的值也为 0，因此，处理器会将计算后的结果（也就是 1）写回到内存中，此时内存中变量 i 的值就变成了 1。如果不相等的话，处理器会再次从内存中读取 i 的值，再次比较。（详细部分可见上面提到的原文）</p>

<p>当然，原子操作不仅仅可以实现读写，还有一些其它的用处。比如，可以用来实现队列锁算法。这种队列和普通的队列大体上是相同的，也具有入队、出队操作以及队头、队尾的描述形式。但由于多核处理器在硬件上不支持这种队列，因此可以使用 CAS 来实现。</p>

<h2 id="自旋和阻塞">自旋和阻塞</h2>

<p>如果一个线程 B 想要获得某个已经被线程 A 使用的锁（临界资源）的时候，将会发生两种情况：自旋（Spinning）和阻塞（Blocking）：</p>

<p><strong>自旋</strong>：在进行自旋的时候，线程 B 会一直保持<code>尝试获取锁</code>的这种状态，即一直循环检测锁是否被释放，而不是进入线程挂起或睡眠状态。我们可以使用 while 进行实现，即设置某个变量，不断地通过 while 检查该变量的值，等到在某些条件下等于这个值并且返回 true 的时候，就说明线程 B 获取锁成功了。如果线程 B 等待时间很短的话，这种自旋的实现方式是很有效的。而如果自旋时间过长，则会增加计算机的负担，反而会降低其执行效率。</p>

<p><strong>阻塞</strong>：也就是互斥，如果产生阻塞的话，线程 B 会阻塞自己知道临界资源解除占用，然后会再次尝试获取。</p>

<p>如果是竞争非常激烈的场景，在使用自旋的时候会遇到一些其它的问题：</p>

<ul>
<li>可能导致某些线程自始至终都无法获取到锁，这些线程会一直处于饥饿状态；</li>
<li>自旋的时候需要依赖一个共享的锁标识，在竞争激烈的环境下，锁标识的同步也需要消耗大量的资源；</li>
<li>如果想要通过自旋的方式实现公平锁（先到先获取），还需要额外的变量。</li>
</ul>

<p>因此，对于上面所发生的问题，我们可以使用队列锁来实现，即让线程排队获取。队列锁的实现方法主要有 Anderson、Graunke/Thakkar、Mellor-Crummey/Scott(MCS)、Craig-Landin-Hagersten(CLH)。由于 AQS 所使用的队列锁是在 CLH 的基础上改进的，所以这里主要介绍 CLH 的实现方式。</p>

<h2 id="clh">CLH</h2>

<p>由 Craig、Landin、Hagersten 三人首字母命名的自旋锁 CLH 是基于链表实现的无界且公平的先进先出（FIFO）队列，线程在本地局部变量上自旋，不断轮询前置节点的状态。如果发现前置节点已经释放了锁，则会结束自旋操作并获取锁。而 Java 中的 AQS 使用的是 CLH 的一种变体。</p>

<p>原始的 CLH 锁的内部有两个被 ThreadLocal 修饰的变量，分别表示当前的节点 node 以及其前驱（前置）节点 preNode。此外，还有一个被 AtomicReference 修饰的原子引用变量 tail 指向队列的尾部。具体加锁和释放锁的过程如下所示：</p>

<ul>
<li>首先会创建一个节点，并将该节点置为 true，表示尝试获取锁；</li>
<li>然后将 tail 指向该节点，表示该节点为当前队列的尾部，并且会获得前置节点的引用，即 locked；</li>
<li>判断前置节点的状态，如果为 true，则<strong>在前置节点上自旋</strong>，直到获取到锁；</li>
<li>当前线程释放锁时，将 locked 状态置为 false，并将当前节点指向前置节点。</li>
</ul>

<p>以下是 CLH 的简单实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public class CLH implements </span><span class="n">Lock</span> <span class="p">{</span>
    <span class="err">private final ThreadLocal&lt;Node&gt; preNode </span><span class="o">=</span> <span class="n">ThreadLocal</span><span class="p">.</span><span class="na">withInitial</span><span class="p">(()</span> <span class="o">-&gt;</span> <span class="kc">null</span><span class="p">);</span>
    <span class="err">private final ThreadLocal&lt;Node&gt; node </span><span class="o">=</span> <span class="n">ThreadLocal</span><span class="p">.</span><span class="na">withInitial</span><span class="p">(</span><span class="n">Node</span><span class="o">::</span><span class="k">new</span><span class="p">);</span>
    <span class="err">private final AtomicReference&lt;Node&gt; tail </span><span class="o">=</span> <span class="k">new</span> <span class="n">AtomicReference</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Node</span><span class="p">());</span>

    <span class="err">private static class Node </span><span class="p">{</span>
        <span class="err">private volatile boolean locked</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">@Override</span>
    <span class="err">public void </span><span class="n">lock</span><span class="p">()</span> <span class="p">{</span>
        <span class="err">final Node </span><span class="n">node</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="na">node</span><span class="p">.</span><span class="na">get</span><span class="p">();</span>
        <span class="n">node</span><span class="p">.</span><span class="na">locked</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="err">Node pre </span><span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="na">tail</span><span class="p">.</span><span class="na">getAndSet</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
        <span class="k">this</span><span class="p">.</span><span class="na">preNode</span><span class="p">.</span><span class="na">set</span><span class="p">(</span><span class="n">pre</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">pre</span><span class="p">.</span><span class="na">locked</span><span class="p">)</span> <span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">@Override</span>
    <span class="err">public void </span><span class="n">unlock</span><span class="p">()</span> <span class="p">{</span>
        <span class="err">final Node </span><span class="n">node</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="na">node</span><span class="p">.</span><span class="na">get</span><span class="p">();</span>
        <span class="n">node</span><span class="p">.</span><span class="na">locked</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="na">node</span><span class="p">.</span><span class="na">set</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">preNode</span><span class="p">.</span><span class="na">get</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>这里顺带一提 CLH 和 MCS 的区别，这俩都是自旋锁的实现，其区别如下：</p>

<ul>
<li><strong>链表结构不同</strong>

<ul>
<li>CLH 中的链表包含的是当前节点以及前驱节点，而 MCS 中的链表包含的是当前节点以及后继节点。</li>
</ul></li>
<li><strong>自旋对象不同</strong>

<ul>
<li>CLH 的自旋对象是前驱节点，而 MCS 自旋对象是自身节点，也就是当前节点。</li>
</ul></li>
</ul>

<h1 id="aqs">AQS</h1>

<p><center>
<img src="https://i.loli.net/2020/05/02/qstfr9YVcxWJeoI.png" alt="image.png" />
</center></p>

<p>CountDownLatch、ThreadPoolExecutor、ReentrantLock、ReentrantReadWriteLock 以及 Semaphore 中的内部类都继承了 AbstractQueuedSynchronizer。因此，对于 ReentrantLock 的理解是需要建立在 AQS 之上的。<strong>AQS 的核心思想是：如果被请求的共享资源是空闲的，那么就将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态。而如果共享资源被占用，就需要一定的<code>阻塞等待唤醒机制</code>来保证锁的分配。该机制就是使用 CLH 队列的变体实现的，即将暂时获取不到的线程放进队列中</strong>。</p>

<p>上面提到的 CLH 是基于单向链表实现的，而 AQS 中的 CLH 变体是基于双向队列实现的，AQS 通过将每个请求共享资源的线程封装成一个节点来实现锁的分配，当多线程在争用资源被阻塞时会进入此队列。整体实现结构如<a href="https://images2015.cnblogs.com/blog/721070/201705/721070-20170504110246211-10684485.png">下图</a>所示：</p>

<p><center>
<img src="https://i.loli.net/2020/05/02/BspYxH1kohI3WFb.png" alt="image.png" />
</center></p>

<p>在 AQS 的内部类 Node 中定义了该结构，该 Node 表示的就是上图中的每个节点。Node 节点是对每个等待获取资源的线程的封装，它包含了需要同步的线程本身及其等待状态，例如是否被阻塞、是否等待唤醒、是否已经被取消等。</p>

<p>除此之外，AQS 还维护了一个被 volatile 修饰的 state，代表共享资源，访问 state 的方式有以下三种：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">protected final int getState</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span>

<span class="err">protected final void setState</span><span class="p">(</span><span class="err">int newState</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">newState</span><span class="p">;</span>
<span class="p">}</span>

<span class="err">protected final boolean compareAndSetState</span><span class="p">(</span><span class="err">int expect</span><span class="p">,</span> <span class="err">int update</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">unsafe</span><span class="p">.</span><span class="na">compareAndSwapInt</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">stateOffset</span><span class="p">,</span> <span class="n">expect</span><span class="p">,</span> <span class="n">update</span><span class="p">);</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>AQS 定义了两种资源共享的方式：EXCLUSIVE 和 SHARED</code>。EXCLUSIVE 表示独占模式，只能有一个线程执行，例如 ReentrantLock；SHARED 表示共享模式，即多个线程可以同时执行，例如 CountDownLatch、Semaphore。</p>

<p><strong>不同的自定义同步器争用共享资源的方式也是不同的，在实现自定义同步器时只需要实现共享资源 state 的获取和释放方式即可</strong>，至于线程等待队列的维护（例如获取资源失败入队/唤醒出队），AQS 已经在底层实现好了。如果想要自定义同步器，则需要实现以下几个方法：</p>

<ul>
<li><strong>boolean isHeldExclusively()</strong>：表示该线程是否正在独占资源，只有用到 Condition 的时候才需要实现它；</li>
<li><strong>boolean tryAcquire(int arg)</strong>：表示在独占模式下尝试获取资源，成功返回 true，否则返回 false；</li>
<li><strong>boolean tryRelease(int arg)</strong>：表示在独占模式表尝试释放资源，成功返回 true，否则返回 false；</li>
<li><strong>int tryAcquireShared(int arg)</strong>：表示在共享模式下尝试获取资源。

<ul>
<li>返回负数表示失败；</li>
<li>返回 0 表示成功，但没有剩余可用资源；</li>
<li>返回正数表示成功，且有剩余资源。</li>
</ul></li>
<li><strong>boolean tryReleaseShared(int arg)</strong>：表示在共享模式下尝试释放资源，如果释放后允许唤醒后续等待节点则返回 true，否则返回 false。</li>
</ul>

<p>以 ReentrantLock 为例，state 初始化为 0，表示处于未锁定状态。线程 A 执行 lock() 时，会调用 tryAcquire() 独占该锁并将 state+1。此后其它线程再 tryAcquire() 时就会失败，直到线程 A 执行 unlock() 到 state=0 时释放锁为止，其它线程才有机会获取该锁。需要注意的是，在释放锁之前，由于线程 A 已经获取到了锁，因此线程 A 还可以重复获取这个锁，state 会累加，这就是可重入的概念。但获取了多少次就应该释放多少次，这样才能保证 state 回到 0 状态。</p>

<p>以 CountDownLatch 为例，将某个任务分为 N 个子任务并行执行（N 与线程个数一致），state 初始化为 N。每个子任务执行完后每执行 countDown() 一次，state 就会 CAS 减 1。等到所有子任务都执行完以后，即 state=0 时，会 unpark() 主线程，然后主线程就会从 await() 函数返回，继续后续的执行。</p>

<p>一般情况下，自定义同步器可以使用独占方式或共享方式，如果使用独占方式，则实现 tryAcquire() 和 tryRelease() 即可；而如果实现共享方式，则实现 tryAcquireShared() 和 tryReleaseShared() 即可。如果想要同时支持独占和共享的话，可以使用 AQS 提供的 ReentrantReadWriteLock。</p>

<h2 id="waitstatus">waitStatus</h2>

<p>在内部类 Node 中，使用 waitStatus 表示<strong>当前节点在队列中的等待状态</strong>，共有 5 种取值。如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">static final class Node </span><span class="p">{</span>
    <span class="c1">// 表示一个节点在共享模式下处于等待状态，即共享模式
</span><span class="c1"></span>    <span class="err">static final Node SHARED </span><span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">();</span>
    <span class="c1">// 表示一个节点在独占模式下处于等待状态，即独占模式
</span><span class="c1"></span>    <span class="err">static final Node EXCLUSIVE </span><span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

    <span class="err">static final int CANCELLED </span><span class="o">=</span>  <span class="n">1</span><span class="p">;</span>
    <span class="err">static final int SIGNAL    </span><span class="o">=</span> <span class="o">-</span><span class="n">1</span><span class="p">;</span>
    <span class="err">static final int CONDITION </span><span class="o">=</span> <span class="o">-</span><span class="n">2</span><span class="p">;</span>
    <span class="err">static final int PROPAGATE </span><span class="o">=</span> <span class="o">-</span><span class="n">3</span><span class="p">;</span>

    <span class="err">volatile int </span><span class="n">waitStatus</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<ul>
<li>CANCELLED = 1：表示当前节点已取消调度，即当前线程取消获取锁，当 timeout 或被中断，会触发变更为此状态，进入该状态后的节点将不再发生状态的变化；</li>
<li>SIGNAL = -1：表示后继节点等待被当前节点唤醒，也就是说后继节点在被唤醒前是处于阻塞状态的。当后继节点入队时，会将前驱节点的状态更新为 SIGNAL；</li>
<li>CONDITION = -2：表示当前节点等待在 Condition 上，即当前线程位于条件队列，当其它线程调用了 Condition 的 signal() 方法后，CONDITION 状态的节点将从<strong>等待队列转移到同步队列中</strong>，等待获取同步锁；</li>
<li>PROPAGATE = -3：表示在共享模式下，前驱节点不仅会唤醒其后继节点，同时也可能会唤醒后继的后继节点。也就是说，处于共享模式下节点的最终状态，确保在 doReleaseShared 的时候将共享状态继续传播下去；</li>
<li>0：如果当前节点不处于以上任何一种状态的话，则会处于 0 状态，即新节点入队时的默认状态。</li>
</ul>

<p>需要注意的是，负值表示当前节点处于有效等待状态，而正值表示当前节点已被取消。</p>

<h2 id="acquire-int-arg">acquire(int arg)</h2>

<p>AbstractQueuedSynchronizer 类中的 acquire() 方法用于在独占模式下获取资源，如果获取到资源，则线程直接返回，否则进入等待队列，直到获取到资源为止，该过程忽略中断的影响。如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public final void acquire</span><span class="p">(</span><span class="err">int arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tryAcquire</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">acquireQueued</span><span class="p">(</span><span class="n">addWaiter</span><span class="p">(</span><span class="n">Node</span><span class="p">.</span><span class="na">EXCLUSIVE</span><span class="p">),</span> <span class="n">arg</span><span class="p">))</span>
        <span class="n">selfInterrupt</span><span class="p">();</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>acquire(int arg) 方法的流程是：</p>

<ul>
<li>tryAcquire(arg) 尝试直接获取资源，如果成功则直接返回，这里体现了非公平锁，每个线程在获取锁时都会尝试进行抢占；</li>
<li>addWaiter() 将该线程加入到等待队列的尾部，并标记为独占模式；</li>
<li>acquireQueued() 使线程阻塞在等待队列中获取资源，一直获取到资源后才返回，如果在整个等待过程中被中断过，则返回 true，否则返回 false；</li>
<li>如果线程在等待过程中被中断过，它是不会响应的，只是获取资源后再进行自我中断，即 selfInterrupt()。</li>
</ul>

<h3 id="tryacquire-int-arg">tryAcquire(int arg)</h3>

<p>该方法在独占模式下尝试获取资源，获取成功返回 true，否则返回 false。如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">protected boolean </span><span class="n">tryAcquire</span><span class="p">(</span><span class="err">int arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">UnsupportedOperationException</span><span class="p">();</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>此方法直接抛出异常，是因为 AQS 只是一个框架，具体获取和释放操作由自定义同步器来实现。因此，该方法需要被重写，具体重写的方式是：可以规定为如果返回 true，则表示获取锁成功，反之失败。</p>

<p>回到 acquire(int arg) 方法中，如果 tryAcquire(int arg) 获取锁成功了，则 acquire 方法直接返回，如果失败了，则继续后面的操作，即将线程放进等待队列中，也就是 &amp;&amp; 符号后面的 acquireQueued() 方法。但在此之前，需要先了解 addWaiter(Node mode) 方法，</p>

<h3 id="addwaiter-node-mode">addWaiter(Node mode)</h3>

<p>该方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的节点，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 位于 Node 类中
</span><span class="c1"></span><span class="err">Node nextWaiter</span><span class="p">;</span>

<span class="c1">// 位于 Node 类中
</span><span class="c1"></span><span class="n">Node</span><span class="p">(</span><span class="err">Thread thread</span><span class="p">,</span> <span class="err">Node mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="na">nextWaiter</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="na">thread</span> <span class="o">=</span> <span class="n">thread</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 位于 AbstractQueuedSynchronizer 类中
</span><span class="c1"></span><span class="err">private Node </span><span class="n">addWaiter</span><span class="p">(</span><span class="err">Node mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">Node node </span><span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">(),</span> <span class="n">mode</span><span class="p">);</span>

    <span class="err">Node pred </span><span class="o">=</span> <span class="n">tail</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pred</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">node</span><span class="p">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pred</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">compareAndSetTail</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">pred</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">enq</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>流程如下：</p>

<ul>
<li>使用 Node 含参构造器创建一个 Node 对象，即构造一个当前线程的节点 node；</li>
<li>将刚刚创建的 node 放到队尾：

<ul>
<li>首先获取尾节点，如果尾节点不为 null，则将 node 放到队尾，通过 CAS 的方式设置队尾节点，如果成功，则将刚刚创建的节点 node 设置为原来队尾节点的 next，然后返回。</li>
</ul></li>
<li>如果尾节点 tail 是 null，则调用 enq() 方法。</li>
</ul>

<p>enq() 方法如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">private Node </span><span class="n">enq</span><span class="p">(</span><span class="err">final Node </span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="err">Node t </span><span class="o">=</span> <span class="n">tail</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Must initialize
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">compareAndSetHead</span><span class="p">(</span><span class="k">new</span> <span class="n">Node</span><span class="p">()))</span>
                <span class="n">tail</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">node</span><span class="p">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">compareAndSetTail</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">t</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>该方法用于将 node 加入队尾，采用 CAS 自旋的方式直到成功加入到队尾。首先获取到队尾 t，如果 t 为空，说明队列没有进行初始化，因此需要进行初始化操作。这里采用 CAS 的方式创建一个空的标志节点作为 head 节点，并将 tail 指向 head。而如果 t 不为空，则直接执行 CAS 操作将 node 插入到队列尾部。</p>

<p>再次回到 acquire(int arg)，此时需要了解的是 acquireQueued() 方法。</p>

<h3 id="acquirequeued-final-node-node-int-arg">acquireQueued(final Node node, int arg)</h3>

<p>前面执行了 tryAcquire() 方法和 addWaiter() 方法，此时表明该线程获取资源失败，已经被放进等待队列尾部了。<strong>下一步就是进入等待状态，直到其它线程释放资源后唤醒该线程，然后该线程再去获取资源</strong>。acquireQueued() 方法就是让线程阻塞在等待队列中获取资源，一直获取到资源后才返回，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">final boolean </span><span class="n">acquireQueued</span><span class="p">(</span><span class="err">final Node </span><span class="n">node</span><span class="p">,</span> <span class="err">int arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 表示是否成功拿到资源
</span><span class="c1"></span>    <span class="err">boolean failed </span><span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="c1">// 表示等待过程中是否被中断过
</span><span class="c1"></span>        <span class="err">boolean interrupted </span><span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        <span class="c1">// 自旋操作
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
            <span class="c1">// 获得当前节点 node 的前驱节点
</span><span class="c1"></span>            <span class="err">final Node </span><span class="n">p</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="na">predecessor</span><span class="p">();</span>
            <span class="c1">// 如果前驱节点是头节点，则说明当前节点 node 是第二个节点，
</span><span class="c1"></span>            <span class="c1">// 因此便有资格去尝试获取资源
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">head</span> <span class="o">&amp;&amp;</span> <span class="n">tryAcquire</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span> <span class="p">{</span>
                <span class="c1">// 将 head 指向当前节点 node
</span><span class="c1"></span>                <span class="n">setHead</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
                <span class="c1">// 经过 setHead() 后，node.prev 已经指向了 null，
</span><span class="c1"></span>                <span class="c1">// 此时再将 p.next 置为 null，便于 GC 回收，
</span><span class="c1"></span>                <span class="c1">// 也就意味着之前拿完资源的节点出队了
</span><span class="c1"></span>                <span class="n">p</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
                <span class="c1">// 表示成功获取到资源
</span><span class="c1"></span>                <span class="n">failed</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
                <span class="c1">// 返回等待过程中是否被中断过
</span><span class="c1"></span>                <span class="k">return</span> <span class="n">interrupted</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// 如果当前线程可以休息了，就通过 park() 进入 waiting 状态，直到 unpark()，
</span><span class="c1"></span>            <span class="c1">// 如果在不可中断的情况下被中断了，则会从 park() 中醒过来，会发现拿不到资源，
</span><span class="c1"></span>            <span class="c1">// 从而继续进入 park() 等待
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">shouldParkAfterFailedAcquire</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">parkAndCheckInterrupt</span><span class="p">())</span>
                <span class="c1">// 如果等待过程中被中断过，就将 interrupted 标记为 true
</span><span class="c1"></span>                <span class="n">interrupted</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
        <span class="c1">// 如果等待过程中没有成功获取到资源，例如 timeout 或可中断的情况下被中断了，
</span><span class="c1"></span>        <span class="c1">// 那么取消节点在队列中的等待
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">failed</span><span class="p">)</span>
            <span class="n">cancelAcquire</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>从注释中可以看到基本的执行流程，在梳理流程之前，这里再看一下 shouldParkAfterFailedAcquire() 和 parkAndCheckInterrupt() 方法的作用。</p>

<p>首先看一下 <strong>shouldParkAfterFailedAcquire()</strong> 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">private static boolean shouldParkAfterFailedAcquire</span><span class="p">(</span><span class="err">Node pred</span><span class="p">,</span> <span class="err">Node node</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 获得前驱节点 pred 的状态
</span><span class="c1"></span>    <span class="err">int ws </span><span class="o">=</span> <span class="n">pred</span><span class="p">.</span><span class="na">waitStatus</span><span class="p">;</span>
    <span class="c1">// 这个地方怎么理解呢？
</span><span class="c1"></span>    <span class="c1">// 如果之前已经告诉前驱节点：你拿到资源后要通知一下我哈
</span><span class="c1"></span>    <span class="c1">// 也就是说，如果前驱节点处于这种 SIGNAL 状态的时候，
</span><span class="c1"></span>    <span class="c1">// 那么我就可以直接返回了
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">ws</span> <span class="o">==</span> <span class="n">Node</span><span class="p">.</span><span class="na">SIGNAL</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ws</span> <span class="o">&gt;</span> <span class="n">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 来到这里说明前驱节点取消获取锁的操作，那就一直往前找，
</span><span class="c1"></span>        <span class="c1">// 直到找到最近的一个处于等待状态的节点，并插在该节点的后面，
</span><span class="c1"></span>        <span class="c1">// 那些已经略过的节点，即那些大于 0 状态的节点都会失效，被 GC 回收
</span><span class="c1"></span>        <span class="k">do</span> <span class="p">{</span>
            <span class="n">node</span><span class="p">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="p">.</span><span class="na">prev</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pred</span><span class="p">.</span><span class="na">waitStatus</span> <span class="o">&gt;</span> <span class="n">0</span><span class="p">);</span>
        <span class="n">pred</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 如果前驱节点正常，则通过 CAS 的方式将前驱节点设置成 SIGNAL 状态，
</span><span class="c1"></span>        <span class="c1">// 告诉它：获取到资源后通知一下我（当前节点）
</span><span class="c1"></span>        <span class="n">compareAndSetWaitStatus</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">Node</span><span class="p">.</span><span class="na">SIGNAL</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>再来看一下 <strong>parkAndCheckInterrupt()</strong> 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">private final boolean parkAndCheckInterrupt</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">LockSupport</span><span class="p">.</span><span class="na">park</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Thread</span><span class="p">.</span><span class="na">interrupted</span><span class="p">();</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>该方法会通过 park() 让当前线程进入 waiting 状态，等到有别的线程唤醒，然后返回当前线程是否被中断了。需要注意的是，Thread.interrupted() 方法会清除当前线程的中断标记位，即清除中断状态。</p>

<p>再次回到 acquireQueued() 方法，具体流程就是将刚刚创建的线程节点挂起，然后等待唤醒，如果被唤醒了，则将自己设置为 head，最后返回是否被中断。</p>

<p>将以上方法介绍完以后，再次回到 acquire(int arg) 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public final void acquire</span><span class="p">(</span><span class="err">int arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tryAcquire</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">acquireQueued</span><span class="p">(</span><span class="n">addWaiter</span><span class="p">(</span><span class="n">Node</span><span class="p">.</span><span class="na">EXCLUSIVE</span><span class="p">),</span> <span class="n">arg</span><span class="p">))</span>
        <span class="n">selfInterrupt</span><span class="p">();</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>现在总结一下 acquire() 方法的流程：</p>

<ul>
<li>首先通过 tryAcquire(arg) 方法尝试获取资源，如果成功则直接返回；</li>
<li>如果没有成功，则需要通过 addWaiter() 方法将该线程加入等待队列的尾部，并标记为独占模式；</li>
<li>acquireQueued() 使线程在等待队列中休息，轮到自己获取资源的时候会被 unpark()，然后去获取资源，进行返回。如果在整个等待过程中被中断过，则返回 true，否则返回 false；</li>
<li>如果线程在整个等待过程中被中断过，它是不响应的。只是获取资源后才进行自我中断 selfInterrupt()。</li>
</ul>

<p>下图来自<a href="https://www.cnblogs.com/waterystone/p/4920797.html">水岩</a>：</p>

<p><center>
<img src="https://i.loli.net/2020/05/04/Az3OH1QXs94iacr.png" alt="image.png" />
</center></p>

<h2 id="release-int-arg">release(int arg)</h2>

<p>该方法用于在独占模式下释放共享资源，可以用来实现 unlock() 方法，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public final boolean release</span><span class="p">(</span><span class="err">int arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tryRelease</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span> <span class="p">{</span>
        <span class="err">Node h </span><span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="p">.</span><span class="na">waitStatus</span> <span class="o">!=</span> <span class="n">0</span><span class="p">)</span>
            <span class="n">unparkSuccessor</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>首先通过 tryRelease(arg) 尝试释放资源，如果成功，则获取头节点，当头节点不为空并且还有资源的话，则唤醒等待队列里的下一个线程。需要注意的是，release(int arg) 方法的返回值是根据 tryRelease() 方法的返回值来判断线程是否已经完成释放掉资源了。</p>

<h3 id="tryrelease-int-arg">tryRelease(int arg)</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">protected boolean </span><span class="n">tryRelease</span><span class="p">(</span><span class="err">int arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">UnsupportedOperationException</span><span class="p">();</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>release() 方法被 final 修饰，因此不能重写，但我们可以重写 tryRelease() 方法。该方法在独占模式下通过设置 state 的状态来尝试释放资源。由于是独占模式，因此如果某个线程要释放资源的话，那么它肯定已经拿到独占的资源了，直接通过<code>state -= arg</code>减掉相应的资源即可。如果已经将资源彻底释放了（state=0），则返回 true，否则返回 false。</p>

<h3 id="unparksuccessor-node-node">unparkSuccessor(Node node)</h3>

<p>该方法通过 unpark() 来唤醒等待队列中的下一个线程，也就是当前节点的后继节点。需要注意的是，需要确保后继节是存在的，如果后继节点不存在，则无法唤醒。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">private void </span><span class="n">unparkSuccessor</span><span class="p">(</span><span class="err">Node node</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 获得当前节点的状态
</span><span class="c1"></span>    <span class="err">int ws </span><span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="na">waitStatus</span><span class="p">;</span>
    <span class="c1">// 通过 CAS 将当前节点的状态置为 0
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">ws</span> <span class="o">&lt;</span> <span class="n">0</span><span class="p">)</span>
        <span class="n">compareAndSetWaitStatus</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">0</span><span class="p">);</span>

    <span class="c1">// 找到下一个需要唤醒的节点，也就是当前节点的后继节点
</span><span class="c1"></span>    <span class="err">Node s </span><span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
    <span class="c1">// 如果后继节点为空或后继节点已经取消获取锁了
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="p">.</span><span class="na">waitStatus</span> <span class="o">&gt;</span> <span class="n">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">s</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
        <span class="c1">// 从队尾往队头开始找，找到第一个状态是小于等于 0 的节点
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="err">Node t </span><span class="o">=</span> <span class="n">tail</span><span class="p">;</span> <span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">node</span><span class="p">;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="na">prev</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="na">waitStatus</span> <span class="o">&lt;=</span> <span class="n">0</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 找到后将其唤醒
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span>
        <span class="n">LockSupport</span><span class="p">.</span><span class="na">unpark</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="na">thread</span><span class="p">);</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>需要注意的是，release() 只是将队列中第一个满足条件的线程唤醒，所以接下来的逻辑还是在 acquireQueued() 方法中，继续尝试 tryAcquire()，如果成功，则会被出队（当前节点设为头节点），线程继续执行，否则继续等待。</p>

<p><strong>综上，release() 方法是独占模式下线程释放共享资源的顶级入口，它会释放指定数量的资源，如果彻底释放了（state=0），则它会唤醒等待队列里的其它线程来获取资源</strong>。</p>

<h2 id="acquireshared-int-arg">acquireShared(int arg)</h2>

<p>该方法是处于共享模式下线程获取资源的顶级入口，它会获取指定数量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取成功为止，整个过程是忽略中断的。如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public final void acquireShared</span><span class="p">(</span><span class="err">int arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tryAcquireShared</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">0</span><span class="p">)</span>
        <span class="n">doAcquireShared</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>这里的 tryAcquireShared(arg) 表示在共享模式下尝试获取资源，它的返回值也代表了不同的含义：</p>

<ul>
<li>负值代表获取失败；</li>
<li>0 值代表获取成功，但没有剩余资源；</li>
<li>正数代表获取成功，还有剩余资源，其它线程还可以去获取。</li>
</ul>

<p>而 acquireShared(int arg) 的整体流程就是：首先通过 tryAcquireShared(arg) 尝试获取资源，成功则直接返回，如果失败，则通过 doAcquireShared(arg) 进入等待队列，直到获取到资源为止再返回。</p>

<h3 id="doacquireshared-int-arg">doAcquireShared(int arg)</h3>

<p>该方法是以共享的、不可中断的方式获取资源为基础的，将当前线程加入等待队列的尾部，直到其它线程释放资源唤醒自己，自己成功拿到对应数量的资源时再返回，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">private void </span><span class="n">doAcquireShared</span><span class="p">(</span><span class="err">int arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 创建节点并加入到队列的尾部
</span><span class="c1"></span>    <span class="err">final Node </span><span class="n">node</span> <span class="o">=</span> <span class="n">addWaiter</span><span class="p">(</span><span class="n">Node</span><span class="p">.</span><span class="na">SHARED</span><span class="p">);</span>
    <span class="c1">// 用于标识是否成功
</span><span class="c1"></span>    <span class="err">boolean failed </span><span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="c1">// 用于标识等待过程中是否被中断过
</span><span class="c1"></span>        <span class="err">boolean interrupted </span><span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
            <span class="c1">// 获得当前节点的前驱
</span><span class="c1"></span>            <span class="err">final Node </span><span class="n">p</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="na">predecessor</span><span class="p">();</span>
            <span class="c1">// 由于 head 是拿到资源的线程，
</span><span class="c1"></span>            <span class="c1">// 如果当前节点的前驱是 head，则当前节点 node 需要被唤醒，
</span><span class="c1"></span>            <span class="c1">// 也就是 head 用完了资源来唤醒当前节点 node
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 尝试获取资源
</span><span class="c1"></span>                <span class="err">int r </span><span class="o">=</span> <span class="n">tryAcquireShared</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
                <span class="c1">// 获取成功
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// 将 head 指向当前节点 node，
</span><span class="c1"></span>                    <span class="c1">// 如果还有剩余资源，则可以再唤醒 node 之后的线程
</span><span class="c1"></span>                    <span class="n">setHeadAndPropagate</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
                    <span class="n">p</span><span class="p">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// help GC
</span><span class="c1"></span>                    <span class="c1">// 如果等待过程中被中断过，则补上中断
</span><span class="c1"></span>                    <span class="k">if</span> <span class="p">(</span><span class="n">interrupted</span><span class="p">)</span>
                        <span class="n">selfInterrupt</span><span class="p">();</span>
                    <span class="n">failed</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
                    <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="c1">// 如果当前节点 node 的前驱不是 head，
</span><span class="c1"></span>            <span class="c1">// 则寻找安全点，进入 waiting 状态，等待被 unpark() 或被 interrput()
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">shouldParkAfterFailedAcquire</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                <span class="n">parkAndCheckInterrupt</span><span class="p">())</span>
                <span class="n">interrupted</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">failed</span><span class="p">)</span>
            <span class="n">cancelAcquire</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>以上方法的执行过程和 acquireQueued(final Node node, int arg) 类似，这里只有线程是 head.next 的时候才回去尝试获取资源，还有剩余的话则会唤醒之后的线程。</p>

<p>假设如下场景：如果 head 节点释放了 5 个资源，而 node 节点需要 6 个，node.next 需要 1 个，node.next.next 需要 2 个，head 先唤醒了 node，node 一看资源不够，那它会把资源让给 node.next　吗？</p>

<p>不会的，node 由于资源不够，它会一直 park() 等待其它线程释放资源，也不会去唤醒 node.next 和 node.next.next。在独占模式下，同一时刻只有一个线程去执行，这样是可以的。而共享模式下，多线程可以同时执行，由于 node 需求量大，而将 node.next 和 node.next.next 阻塞了，这样做是由于 AQS 的公平性，保证了唤醒的顺序是按照入队顺序执行的，但可以看出，这样做虽然保证了公平，但降低了并发量。</p>

<h3 id="setheadandpropagate-node-node-int-propagate">setHeadAndPropagate(Node node, int propagate)</h3>

<p>从下面的方法中可以看出，在唤醒自己（当前节点 ndoe）的同时，（如果还有资源的话）还回去唤醒后继节点，这是因为处于共享模式下的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">private void </span><span class="n">setHeadAndPropagate</span><span class="p">(</span><span class="err">Node node</span><span class="p">,</span> <span class="err">int propagate</span><span class="p">)</span> <span class="p">{</span>
    <span class="err">Node h </span><span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="c1">// 让 head 指向当前节点 node
</span><span class="c1"></span>    <span class="n">setHead</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="c1">// 如果还有剩余资源，则唤醒当前节点 node 之后的线程
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">propagate</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">||</span> <span class="n">h</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">h</span><span class="p">.</span><span class="na">waitStatus</span> <span class="o">&lt;</span> <span class="n">0</span> <span class="o">||</span>
        <span class="p">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="p">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">h</span><span class="p">.</span><span class="na">waitStatus</span> <span class="o">&lt;</span> <span class="n">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="err">Node s </span><span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="na">next</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="p">.</span><span class="na">isShared</span><span class="p">())</span>
            <span class="n">doReleaseShared</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><strong>这里对 acquireShared(int arg) 做一个小结</strong>：</p>

<ul>
<li>通过 tryAcquireShared(arg) 尝试获取资源，成功则直接返回；</li>
<li>失败则通过 doAcquireShared(arg) 进入等待队列进行 park() 操作，直到被 unpark() 或 interrupt() 并成功获取到资源在返回，整个过程是忽略中断的。</li>
</ul>

<p><code>共享模式</code>体现在：当前节点 node 拿到资源后，它会唤醒后继节点（线程），让后继节点再去准备获取资源。</p>

<h2 id="releaseshared-int-arg">releaseShared(int arg)</h2>

<p>该方法是在共享模式下释放指定量的资源，如果成功释放且允许唤醒等待的线程，则它会唤醒等待队列里的其它线程来获取资源，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">public final boolean releaseShared</span><span class="p">(</span><span class="err">int arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 尝试释放资源
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">tryReleaseShared</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// 唤醒后继节点
</span><span class="c1"></span>        <span class="n">doReleaseShared</span><span class="p">();</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>与独占模式下的 tryRelease() 不同的是：tryRelease() 是在<strong>完全</strong>释放完资源（state=0）后，才会返回 true 并唤醒其它线程；而共享模式下的 releaseShared() 则没有这种<strong>完全</strong>的要求，而是拥有资源的线程在释放掉<strong>部分</strong>资源后就可以唤醒后续等待的线程。</p>

<p>例如资源总量是 13，线程 A 获取了 5 个资源，线程 B 获取了 7 个资源，然后并发执行，此时还剩下 1 个资源。等到线程 C 到来时，由于 C 需要获取 4 个资源才能运行，因此线程 C 目前由于资源不够而处于等待状态。当线程 A 释放了 2 个资源后，通过 tryReleaseShared(2) 返回 true 唤醒线程 C，线程 C 发现目前有 3 个资源，还是继续等待。然后线程 B 又释放了 2 个资源，通过 tryReleaseShared(2) 返回 true 唤醒线程 C，线程 C 看到总共有 5 个资源够用了，因此线程 C 就会和线程 A 和 B 一起运行了。</p>

<p>需要注意的是，ReentrantReadWriteLock 的 tryReleaseShared() 只有在完全释放掉资源（state=0）时才返回 true，因此自定义同步器可以根据需要来决定 tryReleaseShared() 的返回值。</p>

<h3 id="doreleaseshared">doReleaseShared()</h3>

<p>该方法用于在共享模式下唤醒当前节点的后继节点，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="err">private void </span><span class="n">doReleaseShared</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="err">Node h </span><span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">h</span> <span class="o">!=</span> <span class="n">tail</span><span class="p">)</span> <span class="p">{</span>
            <span class="err">int ws </span><span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="na">waitStatus</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ws</span> <span class="o">==</span> <span class="n">Node</span><span class="p">.</span><span class="na">SIGNAL</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">compareAndSetWaitStatus</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">Node</span><span class="p">.</span><span class="na">SIGNAL</span><span class="p">,</span> <span class="n">0</span><span class="p">))</span>
                    <span class="k">continue</span><span class="p">;</span>            <span class="c1">// loop to recheck cases
</span><span class="c1"></span>                <span class="c1">// 唤醒后继节点
</span><span class="c1"></span>                <span class="n">unparkSuccessor</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ws</span> <span class="o">==</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">compareAndSetWaitStatus</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">0</span><span class="p">,</span> <span class="n">Node</span><span class="p">.</span><span class="na">PROPAGATE</span><span class="p">))</span>
                <span class="k">continue</span><span class="p">;</span>                <span class="c1">// loop on failed CAS
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">==</span> <span class="n">head</span><span class="p">)</span>                   <span class="c1">// loop if head changed
</span><span class="c1"></span>            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h1 id="小结">小结</h1>

<p>以上的全部就是对 AQS 的源码分析了，下面再对<code>独占模式</code>和<code>共享模式</code>的主要方法做一个总结：</p>

<ul>
<li><strong>boolean isHeldExclusively()</strong>：表示该线程是否正在独占资源，只有用到 Condition 的时候才需要实现它；</li>
<li><strong>boolean tryAcquire(int arg)</strong>：表示在独占模式下尝试获取资源，成功返回 true，否则返回 false；</li>
<li><strong>boolean tryRelease(int arg)</strong>：表示在独占模式表尝试释放资源，成功返回 true，否则返回 false；</li>
<li><strong>int tryAcquireShared(int arg)</strong>：表示在共享模式下尝试获取资源。

<ul>
<li>返回负数表示失败；</li>
<li>返回 0 表示成功，但没有剩余可用资源；</li>
<li>返回正数表示成功，且有剩余资源。</li>
</ul></li>
<li><strong>boolean tryReleaseShared(int arg)</strong>：表示在共享模式下尝试释放资源，如果释放后允许唤醒后续等待节点则返回 true，否则返回 false。</li>
</ul>

<p>因此，总体的思想就是在实现自定义同步器的时候，我们只需要实现共享资源 state 的获取方式和释放方式即可，而具体的线程等待与维护的细节，AQS 已经实现好了。</p>

<p>本文是在阅读参考文章后完成的，不得不说，AQS 的内部细节需要注意的地方太多，理解起来也不是那么的容易。也可能现在不是很理解，但我想，等到过了一个月、三个月或者更长时间后，再来回顾这篇文章，通过不断的学习，等到再次遇到 AQS 的时候，我会对它有一个更加清晰的认识。</p>

<h1 id="参考">参考</h1>

<ul>
<li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-852j-distributed-algorithms-fall-2009/lecture-notes/MIT6_852JF09_lec15.pdf">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-852j-distributed-algorithms-fall-2009/lecture-notes/MIT6_852JF09_lec15.pdf</a></li>
<li><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html</a></li>
<li><a href="https://www.cnblogs.com/xmzJava/p/8453774.html">https://www.cnblogs.com/xmzJava/p/8453774.html</a></li>
<li><a href="https://juejin.im/post/5ae1b4f0f265da0b7b359d7a">https://juejin.im/post/5ae1b4f0f265da0b7b359d7a</a></li>
<li><a href="https://www.cnblogs.com/xrq730/p/4979021.html">https://www.cnblogs.com/xrq730/p/4979021.html</a></li>
<li><a href="https://www.cnblogs.com/waterystone/p/4920797.html">https://www.cnblogs.com/waterystone/p/4920797.html</a></li>
<li><a href="https://russxia.com/2018/06/01/%E5%9F%BA%E4%BA%8E%E8%87%AA%E6%97%8B%E7%9A%84CLH%E9%94%81/">https://russxia.com/2018/06/01/%E5%9F%BA%E4%BA%8E%E8%87%AA%E6%97%8B%E7%9A%84CLH%E9%94%81/</a></li>
</ul>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Carol</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2020-05-01
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">Reward</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="https://i.loli.net/2019/11/17/zU4q6LiShYpHrdZ.png">
        <span>wechat</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="https://i.loli.net/2019/11/17/Xnlykx8W3f6DvFi.png">
        <span>alipay</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/Java/">Java</a>
          <a href="/tags/Concurrent/">Concurrent</a>
          <a href="/tags/AbstractQueuedSynchronizer/">AbstractQueuedSynchronizer</a>
          <a href="/tags/Lock/">Lock</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/2020/05/07/Java-ReentrantLock/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Java 中的 ReentrantLock</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/2020/04/29/Java-Atomic/">
            <span class="next-text nav-default">Java 中的 Atomic 包</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'SirCarol';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://twitter.com/SirCarol_" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://github.com/dyfloveslife" class="iconfont icon-github" title="github"></a>
  
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Carol</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
