<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Java 中的 ReentrantLock - Carol&#39;s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Carol" /><meta name="description" content="上篇文章《Java 中的 AQS》 对 AbstractQueuedSynchronizer 中的方法及实现方式做了详细的解释。有了 AQS 和 CAS 的基础以后，我们再来分析 ReentrantLock 就会更加容易一些。
" /><meta name="keywords" content="Java, blog, carol" />






<meta name="generator" content="Hugo 0.84.0 with theme even" />


<link rel="canonical" href="http://localhost:1313/2020/05/07/Java-ReentrantLock/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.a289a5a4.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Java 中的 ReentrantLock" />
<meta property="og:description" content="上篇文章《Java 中的 AQS》 对 AbstractQueuedSynchronizer 中的方法及实现方式做了详细的解释。有了 AQS 和 CAS 的基础以后，我们再来分析 ReentrantLock 就会更加容易一些。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/2020/05/07/Java-ReentrantLock/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-05-07T15:35:11&#43;08:00" />
<meta property="article:modified_time" content="2020-05-07T15:54:11&#43;08:00" />

<meta itemprop="name" content="Java 中的 ReentrantLock">
<meta itemprop="description" content="上篇文章《Java 中的 AQS》 对 AbstractQueuedSynchronizer 中的方法及实现方式做了详细的解释。有了 AQS 和 CAS 的基础以后，我们再来分析 ReentrantLock 就会更加容易一些。"><meta itemprop="datePublished" content="2020-05-07T15:35:11&#43;08:00" />
<meta itemprop="dateModified" content="2020-05-07T15:54:11&#43;08:00" />
<meta itemprop="wordCount" content="5672">
<meta itemprop="keywords" content="Java,Concurrent,ReentrantLock,Lock," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java 中的 ReentrantLock"/>
<meta name="twitter:description" content="上篇文章《Java 中的 AQS》 对 AbstractQueuedSynchronizer 中的方法及实现方式做了详细的解释。有了 AQS 和 CAS 的基础以后，我们再来分析 ReentrantLock 就会更加容易一些。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Carol&#39;s blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Carol&#39;s blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Java 中的 ReentrantLock</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-05-07 </span>
        <div class="post-category">
            <a href="/categories/Java/"> Java </a>
            </div>
          <span class="more-meta"> 5672 words </span>
          <span class="more-meta"> 12 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#公平锁">公平锁</a></li>
    <li><a href="#非公平锁">非公平锁</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>上篇文章<a href="https://dyfloveslife.github.io/2020/05/01/Java-AQS/">《Java 中的 AQS》</a> 对 AbstractQueuedSynchronizer 中的方法及实现方式做了详细的解释。有了 AQS 和 <a href="https://dyfloveslife.github.io/2020/04/29/Java-Atomic/#cas">CAS</a> 的基础以后，我们再来分析 ReentrantLock 就会更加容易一些。</p>
<h1 id="概述">概述</h1>
<p>之前在 <a href="https://dyfloveslife.github.io/2020/04/05/Java-Lock/">《Java 中的 Lock 及各种锁的概念》</a> 中提到了 Lock 这个接口，讲到了里面涉及的几个方法。虽然也简单的介绍了 Lock 接口的唯一实现类 ReentrantLock，但只是简单介绍了里面的方法，而对于一些其它的具体实现（例如公平锁和非公平锁是如何实现的）则没有较为详细的介绍。因此，我想通过这篇文章对 ReentrantLock 进行一次较为细致的理解。或者也可以说，我就将对 ReentrantLock 的理解“输出”成一篇文章。如果有错误或者理解不到位的地方，还请在评论中指出。</p>
<p>在介绍 ReentrantLock 的时候难免会和 synchronized 做对比。在 Java 中实现锁的方式一般可以使用 ReentrantLock 和 synchronized，两者都可以实现线程同步，通过加锁的方式实现对临界资源的互斥访问。但前者实现起来更加灵活，功能更加丰富。例如 ReentrantLock 在加锁期间可以响应中断、设置超时时间等。</p>
<p>以下针对这两种锁在不同方面进行了对比，如下所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">synchronized</th>
<th style="text-align:center">ReentrantLock</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">可重入</td>
<td style="text-align:center"><strong>是</strong></td>
<td style="text-align:center"><strong>是</strong></td>
</tr>
<tr>
<td style="text-align:center">响应中断</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><strong>是</strong></td>
</tr>
<tr>
<td style="text-align:center">超时等待</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><strong>是</strong></td>
</tr>
<tr>
<td style="text-align:center">公平锁</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><strong>是</strong></td>
</tr>
<tr>
<td style="text-align:center">非公平锁</td>
<td style="text-align:center"><strong>是</strong></td>
<td style="text-align:center"><strong>是</strong></td>
</tr>
<tr>
<td style="text-align:center">可尝试加锁</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><strong>是</strong></td>
</tr>
<tr>
<td style="text-align:center">属于Java 内置特性</td>
<td style="text-align:center"><strong>是</strong></td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">自动获取/释放锁</td>
<td style="text-align:center"><strong>是</strong></td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
<p>ReentrantLock 还提供了一些其它的方法用于满足不同的需求。例如，可以通过 isLocked() 方法查询当前的锁是否由任意的线程持有，如果有任意的一个线程持有这把锁，则返回 true，否则返回 false；可以通过 getHoldCount() 方法查询由当前线程加锁的次数。另外，synchronized 使用对象或类进行加锁，而 ReentrantLock 底层是通过 AQS 中的同步队列进行加锁。</p>
<p>接下来简单介绍一下以上提到的特定：</p>
<p><strong>可重入</strong>：</p>
<p>可重入指的是某个线程在执行过程中是否可以再次获取同一把锁。例如由两个方法 foo1() 和 foo2()，这两个方法中都进行了 lock.lock() 以及 lock.unlock() 操作，同时，在 foo1() 中的 try{ } 块中又调用了 foo2()。此时，当线程 A 进入到 foo1() 中后成功获得了锁，然后在没有释放锁的情况下，调用了 foo2() 方法。由于 foo1() 和 foo2() 使用时是同一把可重入锁，因此线程 A 是可以进入到 foo2() 中的，并且再次获得锁，线程 A 不会被阻塞。</p>
<p><strong>而 ReentrantLock 中可重入的实现方式是：通过内部的 AQS 实现的，在 AQS 中有一个变量 state 用于记录同步状态。初始情况下为 0，表示 ReentrantLock 目前处于解锁状态。如果有线程调用 lock() 方法进行加锁，则 state 会加 1。如果该线程再次调用 lock() 方法加锁，则 state 会再次加 1。如果该线程调用 unlock() 方法则会执行 state&ndash;。通过查询 state 的值就可以知道 ReentrantLock 被重入的次数。</strong></p>
<p><strong>响应中断</strong>：</p>
<p>响应中断指的是当某个线程在获取锁的过程中是否可以被其它线程打断，一般通过 Thread.interrupt() 方法中断一个线程，即请求另一个线程在它愿意并方便的时候停止它正在做的事，线程在获取锁的过程中假如被中断了，则会做出响应。synchronized 不可响应中断，一个线程获取不到锁就一直处于阻塞状态。而 ReentrantLock 提供了一个可以响应中断的方法 lockInterruptibly()，如果当前线程被中断了，则会抛出 InterruptedException 异常。</p>
<p><strong>超时等待</strong>：</p>
<p>ReentrantLock 除了能以中断的方式获取锁，还可以通过超时等待的方式获取锁，即如果线程在指定的超时时间内没有获取到锁，则将返回 false，而不是一直处于获取锁的状态。而 synchronized 不支持超时等待。</p>
<p><strong>公平锁/非公平锁</strong>：</p>
<p>公平与非公平指的是线程获取锁的方式。在公平模式下，线程在同步队列中以先进先出（FIFO）的方式获取锁，每个线程最终都能获取到锁。而在非公平模式下，线程会通过“插队”的方式去抢占锁，抢不到的则进入同步队列进行排队。默认情况下，ReentrantLock 属于非公平模式获取锁，但可以通过构造方法 ReentrantLock(boolean fair) 设置获取锁方式的公平与否。</p>
<p>这里再多说一点，在公平模式下的每个线程最终都会获取到锁，但效率较低。而非公平模式下线程在获取锁的过程中可能会出现饥饿的现象，即可能某些线程会始终获取不到锁，每次即将获取到锁时都被其它线程给抢了，但该模式下效率较高。效率高的原因在于：<strong>非公平模式下获取锁的时候，在恢复一个被挂起的线程与线程真正开始运行之间存在着严重的延迟</strong>。具体的说，假如线程 A 持有一把锁，并且线程 B 想请求这把锁。由于该锁已经被线程 A 持有，则线程 B 将会被挂起。只有当线程 A 将锁释放时，线程 B 才会被唤醒，紧接着再去获取锁。如果线程 C 也想获取这把锁，那么很有可能线程 C 会在线程 B <strong>被完全唤醒前</strong>获取、使用以及释放了这把锁。这种情况下，线程 B 获取锁的时刻并没有推迟，而线程 C 更早的获得了锁。因此，这种方式执行的效率要高。</p>
<p><strong>可尝试加锁</strong>：</p>
<p>ReentrantLock 通过使用 tryLock() 方法去尝试获取锁，如果该锁没有被另外一个线程持有，则此方法会立即返回 true，并将锁持有的次数加 1。需要注意的是，即使在公平模式下，只要该锁可用，则调用 tryLock() 方法将会立即获得锁，而不管其它线程当前是否处于等待锁的状态。因此，ReentrantLock 在获取锁的方式上比 synchronized 更具多样性。</p>
<p><strong>属于Java 内置特性</strong>：</p>
<p>有关该特性的说明，已经在<a href="https://dyfloveslife.github.io/2020/04/05/Java-Lock/">《Java 中的 Lock 及各种锁的概念》</a>一文中的<code>概述</code>部分提到过了。简单地说，synchronized 是 Java 的关键字，因此是 Java 的内置特性，是基于 JVM 层面实现的；而 ReentrantLock 是基于 JDK 层面实现的，通过具体的方法实现对线程的同步。</p>
<p><strong>自动获取/释放锁</strong>：</p>
<p>采用 synchronized 方式不需要用户去手动释放锁，当 synchronized 方法或者 synchronized 代码块执行完之后，系统会自动让线程释放对锁的占用；而 ReentrantLock 则必须要用户去手动获取/释放锁 (发生异常时，不会自动释放锁)。特别的，如果没有主动释放锁，就有可能导致死锁现象。</p>
<h1 id="reentrantlock-结构">ReentrantLock 结构</h1>
<p>在之前介绍 AQS 的文章中讲到，ReentrantLock 是基于 AQS 实现，即 ReentrantLock 通过重写<code>获取锁</code>与<code>释放锁</code>的方式来实现<code>公平锁</code>和<code>非公平锁</code>。内部类<code>Sync</code>继承自 AbstractQueuedSynchronizer，并重写了它的 tryRelease() 和 isHeldExclusively() 方法。而另外两个内部类<code>FairSync</code>和<code>NonfairSync</code>都继承自 Sync，分别用来实现公平锁和非公平锁。在这两个类中，都重写了 AbstractQueuedSynchronizer 中的 tryAcquire() 方法。如下图所示：</p>
<!-- raw HTML omitted -->
<p>通过重写的方法可以看到，ReentrantLock 实现的是 AQS 的独占模式，在类型上属于悲观锁。AQS 很好的封装了同步队列的管理、线程的阻塞与唤醒等基础操作。下面看一看 ReentrantLock 的构造器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">final</span> <span class="n">Sync</span> <span class="n">sync</span><span class="o">;</span>

<span class="kd">public</span> <span class="nf">ReentrantLock</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">sync</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NonfairSync</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nf">ReentrantLock</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">fair</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">sync</span> <span class="o">=</span> <span class="n">fair</span> <span class="o">?</span> <span class="k">new</span> <span class="n">FairSync</span><span class="o">()</span> <span class="o">:</span> <span class="k">new</span> <span class="n">NonfairSync</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>正如开头所说，ReentrantLock 默认使用的是<code>非公平锁</code>，也就是说，当我们使用<code>new ReentrantLock();</code>进行初始化的时候，等价于使用<code>new ReentrantLock(false);</code>，通过给构造函数传递一个<code>true/false</code>来实现锁的公平与否。</p>
<h1 id="获取锁">获取锁</h1>
<p>在介绍获取锁的过程之前，先来回顾一下 AQS 中的同步等待队列，该队列是 CLH 队列的变体，是一种基于双向链表的同步队列。线程在获取同步状态失败的情况下，都会被封装成节点，然后加该入队列中，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">      head                                tail
        ↓                                   ↓
     +------+   prev   +------+   prev   +------+
     |||||||| &lt;------- |      | &lt;------- |      |
     |||||||| -------&gt; |      | -------&gt; |      |
     +------+   next   +------+   next   +------+
     头节点已
   获得同步状态
</code></pre></td></tr></table>
</div>
</div><p>在队列中，头节点 head 是获取同步状态的节点，其它节点在尝试获取同步状态失败后，会进入等待队列等待。当头节点释放同步状态后，会唤醒其后继节点。后继节点会将自己设置为头节点，并将之前的头节点从队列中移除（这时大体上的流程，如果你看过 AQS 的源码后会发现，里面还设计到许多细节）。如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">                        head               tail
                          ↓                  ↓
     +------+          +------+   prev   +------+
     |      |          |||||||| &lt;------- |      |
     |      |          |||||||| -------&gt; |      |
     +------+          +------+   next   +------+
     原头节点           头节点已
                      获得同步状态
</code></pre></td></tr></table>
</div>
</div><h2 id="公平锁">公平锁</h2>
<p>在内部类 FairSync 中可以看到公平锁的加锁流程，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// ReentrantLock.FairSync#lock
</span><span class="c1"></span><span class="kd">final</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 调用 AQS 的 acquire 方法
</span><span class="c1"></span>    <span class="n">acquire</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// AbstractQueuedSynchronizer#acquire
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">acquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
        <span class="n">acquireQueued</span><span class="o">(</span><span class="n">addWaiter</span><span class="o">(</span><span class="n">Node</span><span class="o">.</span><span class="na">EXCLUSIVE</span><span class="o">),</span> <span class="n">arg</span><span class="o">))</span>
        <span class="n">selfInterrupt</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// ReentrantLock.FairSync#tryAcquire
</span><span class="c1"></span><span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">Thread</span> <span class="n">current</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
    <span class="c1">// 获得同步状态
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
    <span class="c1">// 同步状态为 0 说明锁暂时没被其它线程获取（占用），不等于 0 说明锁被占用着
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 判断是否有其它线程比当前线程等待的时间更长。
</span><span class="c1"></span>        <span class="c1">// 如果有，则应该先让等待时间更长的节点获得锁；
</span><span class="c1"></span>        <span class="c1">// 如果没有，则让当前线程称为锁的所有者，并调用 compareAndSetState() 尝试设置同步状态。
</span><span class="c1"></span>        <span class="c1">// 这里的逻辑就是实现公平锁的机制，即让先来的线程获取锁，后来的不能抢先获取。
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(!</span><span class="n">hasQueuedPredecessors</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">compareAndSetState</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">acquires</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// 将当前线程设置为持有锁的线程
</span><span class="c1"></span>            <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// 如果当前线程为持有锁的线程，则执行重入逻辑
</span><span class="c1"></span>    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">// 计算重入后的同步状态，acquires 为 1
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">nextc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">acquires</span><span class="o">;</span>
        <span class="c1">// 如果重入次数超过限制，则抛出异常
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">nextc</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">Error</span><span class="o">(</span><span class="s">&#34;Maximum lock count exceeded&#34;</span><span class="o">);</span>
        <span class="c1">// 设置重入后的同步状态
</span><span class="c1"></span>        <span class="n">setState</span><span class="o">(</span><span class="n">nextc</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 如果同步队列中有线程存在且锁的所有者不是当前线程，则返回 false
</span><span class="c1"></span>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// AbstractQueuedSynchronizer#hasQueuedPredecessors
</span><span class="c1">// 用于判断同步队列中是否有比当前线程等待时间更长的线程
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">hasQueuedPredecessors</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 在同步队列中，头节点是已经获取了锁的节点，头节点的后继节点是即将获取锁的节点
</span><span class="c1"></span>    <span class="n">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">s</span><span class="o">;</span>
    <span class="c1">// 如果某个线程等待的时间比当前线程长，则返回 true，否则返回 false
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">h</span> <span class="o">!=</span> <span class="n">t</span> <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="n">s</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">thread</span> <span class="o">!=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当调用公平锁的 lock.lock() 方法后，将会调用 AQS 的 acquire(1) 方法。在 acquire(1) 方法中，首先通过 tryAcquire(arg) 尝试获取锁，该方法由 AQS 的继承类（FairSync）实现，获取成功直接返回。如果 tryAcquire(arg) 返回 false，则调用 addWaiter() 方法，将当前线程封装成节点，并将节点加入到同步队列的尾部。最后调用 acquireQueued() 方法让同步队列中的节点循环尝试获取锁。</p>
<p>如果在同步队列中成功获取锁，则将自己（当前线程）设置为持有锁的线程，然后返回。如果同步状态不为 0，且当前线程为持有锁的线程，则执行重入逻辑。</p>
<h2 id="非公平锁">非公平锁</h2>
<p>在内部类 NonfairSync 中可以看到非公平锁的加锁流程，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// ReentrantLock.NonfairSync
</span><span class="c1"></span><span class="kd">final</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 非公平锁在加锁的时候，会直接调用 CAS 设置 state 变量，如果设置成功，则说明加锁成功。
</span><span class="c1"></span>    <span class="c1">// 这里并没有像公平锁那样调用 acquire() 方法让线程进入同步队列进行排队，而是直接调用
</span><span class="c1"></span>    <span class="c1">// CAS 进行抢占。抢占失败后，才调用 acquire() 方法将线程放入同步队列尾部进行排队
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">1</span><span class="o">))</span>
        <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">());</span>
    <span class="k">else</span>
        <span class="n">acquire</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// AbstractQueuedSynchronizer#acquire
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">acquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
        <span class="n">acquireQueued</span><span class="o">(</span><span class="n">addWaiter</span><span class="o">(</span><span class="n">Node</span><span class="o">.</span><span class="na">EXCLUSIVE</span><span class="o">),</span> <span class="n">arg</span><span class="o">))</span>
        <span class="n">selfInterrupt</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// ReentrantLock.NonfairSync#tryAcquire
</span><span class="c1"></span><span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">nonfairTryAcquire</span><span class="o">(</span><span class="n">acquires</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// ReentrantLock.Sync#nonfairTryAcquire
</span><span class="c1"></span><span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">nonfairTryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">Thread</span> <span class="n">current</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
    <span class="c1">// 获取同步状态
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
    <span class="c1">// 同步状态为 0 说明锁暂时没被其它线程获取（占用），此时可以加锁
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 由于状态可能在检查后被立即修改，因此此处使用 compareAndSetState 来
</span><span class="c1"></span>        <span class="c1">// 原子地更新状态，表示这个锁已经被占有，并确保状态在最后一次检查以后
</span><span class="c1"></span>        <span class="c1">// 就没有被修改过
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="n">0</span><span class="o">,</span> <span class="n">acquires</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// 将当前线程设置为持有锁的线程
</span><span class="c1"></span>            <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// 如果当前线程已经持有锁，即占用锁的线程是自己，则此处为 true，
</span><span class="c1"></span>    <span class="c1">// 表明线程再次获取锁，即重入
</span><span class="c1"></span>    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">// 计算重入后的同步状态，acquires 为 1
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">nextc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">acquires</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">nextc</span> <span class="o">&lt;</span> <span class="n">0</span><span class="o">)</span> <span class="c1">// overflow
</span><span class="c1"></span>            <span class="k">throw</span> <span class="k">new</span> <span class="n">Error</span><span class="o">(</span><span class="s">&#34;Maximum lock count exceeded&#34;</span><span class="o">);</span>
        <span class="c1">// 设置新的同步状态值
</span><span class="c1"></span>        <span class="n">setState</span><span class="o">(</span><span class="n">nextc</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 如果 state 不为 0，且锁的持有者也不是自己，则返回 false，
</span><span class="c1"></span>    <span class="c1">// 然后线程就会进入到同步队列中
</span><span class="c1"></span>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>非公平锁的加锁方式是，首先直接调用 compareAndSetState() 方法进行抢占式的加锁，加锁成功后将当前线程设置为持有锁的线程，然后返回。如果加锁失败，则将会调用 acquire() 方法，将当前线程放入同步队列的尾部进行等待。如果线程在同步队列中成功获取锁，则将自己设置为持有锁的线程，然后返回。如果同步状态不为 0，并且当前线程已经是持有锁的线程，则执行重入操作。</p>
<h1 id="释放锁">释放锁</h1>
<p>不管是公平锁还是非公平锁，它们释放锁的操作都是相同的，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// ReentrantLock#unlock
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 调用 AQS 中的 release 方法
</span><span class="c1"></span>    <span class="n">sync</span><span class="o">.</span><span class="na">release</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// AbstractQueuedSynchronizer#release
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">release</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 调用 ReentrantLock.Sync 中的 tryRelease 方法尝试释放锁
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">tryRelease</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="c1">// 如果出现 head == null 的情况，表示初始的时候 head 指向的是 null，当第一个节点入队后，
</span><span class="c1"></span>        <span class="c1">// head 会被初始化为一个 dummy 节点。如果在其它节点入队之前就调用了 release() 方法，释放同步状态的话，
</span><span class="c1"></span>        <span class="c1">// 则会出现 head == null 的情况。
</span><span class="c1"></span>        <span class="c1">// 如果头节点不等于 null 且等待状态为 0，则表示头节点的后继节点（线程）是活跃的（正在运行的），无需唤醒。
</span><span class="c1"></span>        <span class="c1">// 因此，这里的头节点 h 的等待状态不是 0 的话，说明后继节点对应的线程可能被阻塞了，
</span><span class="c1"></span>        <span class="c1">// 则应该唤醒头节点的后继节点
</span><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">!=</span> <span class="n">0</span><span class="o">)</span>
            <span class="c1">// 唤醒头节点的后继节点
</span><span class="c1"></span>            <span class="n">unparkSuccessor</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// ReentrantLock.Sync#tryRelease
</span><span class="c1"></span><span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryRelease</span><span class="o">(</span><span class="kt">int</span> <span class="n">releases</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 用 getState() 方法得到同步状态减去所释放的量 release，得到本次释放锁后的同步状态量。
</span><span class="c1"></span>    <span class="c1">// 当 state 为 0 的时候，表示锁才完全释放完毕
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">()</span> <span class="o">-</span> <span class="n">releases</span><span class="o">;</span>
    <span class="c1">// 判断当前线程是否已经持有锁，仅允许持有锁的线程执行锁释放的逻辑
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">()</span> <span class="o">!=</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalMonitorStateException</span><span class="o">();</span>
    <span class="kt">boolean</span> <span class="n">free</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="c1">// 如果 c 为 0，则说明已经完全释放锁了，此时需要将持锁线程设为 null
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">free</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 设置新的同步状态
</span><span class="c1"></span>    <span class="n">setState</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">free</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>需要注意的是，在<code>if (c == 0)</code> 进行判断的时候，如果当前线程释放锁之后的状态 state 为 0，则表示锁没有重入了，那么直接将锁的持有者设置为 null 即可，并返回 true，这就说明可以唤醒其它线程去获取锁了。而如果当前线程释放锁之后的状态 state 不为 0，则说明锁被重入了，则会返回 false，代表锁还未完全释放，不需要去唤醒其它线程。</p>
<h1 id="区别">区别</h1>
<p>在获取锁的过程中，公平与非公平的区别在于是否含有 hasQueuedPredecessors() 方法，该方法用于判断<strong>是否其它线程比当前线程在同步队列中等待的时间更长</strong>，有的话返回 true，否则返回 false。如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">      head               node1            node2              tail
        ↓                  ↓                ↓                  ↓
     +------+   prev   +------+   prev   +------+   prev   +------+
     |||||||| &lt;------- |      | &lt;------- |      | &lt;------- |      |
     |||||||| -------&gt; |      | -------&gt; |      | -------&gt; |      |
     +------+   next   +------+   next   +------+   next   +------+
     头节点已
   获得同步状态
</code></pre></td></tr></table>
</div>
</div><p>对于上图来说，节点 node1 对应的线程比节点 node2 对应的线程在等待队列中等待的时间更长。如果 node2 调用 hasQueuedPredecessors() 方法的话，则会返回 true，而 node1 调用 hasQueuedPredecessors() 方法的话，则会返回 false。这时因为 node1 的前驱节点是头节点，它已经获取了同步状态，不处于等待状态。</p>
<p>如果在公平锁中将此方法去掉，则公平锁将不再“公平”，而会像非公平锁那样，抢占失败才会入队。</p>
<h1 id="可中断方式获取锁">可中断方式获取锁</h1>
<p>正如文章开头的表格中所提到的，ReentrantLock 可以响应可中断，即以中断的方式获取锁，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">// ReentrantLock#lockInterruptibly
</span><span class="c1"></span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">lockInterruptibly</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="n">sync</span><span class="o">.</span><span class="na">acquireInterruptibly</span><span class="o">(</span><span class="n">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// AbstractQueuedSynchronizer#acquireInterruptibly
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">acquireInterruptibly</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="c1">// 如果当前线程已经中断了，则抛出异常
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">InterruptedException</span><span class="o">();</span>
    <span class="c1">// 如果当前线程仍未成功获取锁，则调用 doAcquireInterruptibly() 方法，
</span><span class="c1"></span>    <span class="c1">// 该方法在独占的可中断的模式下获取锁
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(!</span><span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span>
        <span class="n">doAcquireInterruptibly</span><span class="o">(</span><span class="n">arg</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="小结">小结</h1>
<p>对于以上获取锁与释放锁的底层实现，其实也在 AQS 那篇文章中讲到了，但本文从 ReentrantLock 层面分析了获取/释放锁的流程，也算是对 AQS 的一次复习和总结。在进行展开的时候，可以先从 synchronized 和 ReentrantLock 的区别说起，然后再逐渐过渡到共享模式和独占模式，最后再谈到在不同模式下的获取锁和释放锁的区别。</p>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html</a></li>
<li><a href="https://www.cnblogs.com/xrq730/p/4979021.html">https://www.cnblogs.com/xrq730/p/4979021.html</a></li>
<li><a href="https://www.cnblogs.com/xmzJava/p/8453774.html">https://www.cnblogs.com/xmzJava/p/8453774.html</a></li>
<li><a href="https://juejin.im/post/5ae1b4f0f265da0b7b359d7a">https://juejin.im/post/5ae1b4f0f265da0b7b359d7a</a></li>
<li><a href="http://www.tianxiaobo.com/2018/05/07/Java-%E9%87%8D%E5%85%A5%E9%94%81-ReentrantLock-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">http://www.tianxiaobo.com/2018/05/07/Java-%E9%87%8D%E5%85%A5%E9%94%81-ReentrantLock-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</a></li>
</ul>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Carol</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2020-05-07
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">Reward</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="https://i.loli.net/2019/11/17/zU4q6LiShYpHrdZ.png">
        <span>wechat</span>
      </label>
    <label class="qr-code-image" for="reward">
        <img class="image" src="https://i.loli.net/2019/11/17/Xnlykx8W3f6DvFi.png">
        <span>alipay</span>
      </label>
  </div>
</div><footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/Java/">Java</a>
          <a href="/tags/Concurrent/">Concurrent</a>
          <a href="/tags/ReentrantLock/">ReentrantLock</a>
          <a href="/tags/Lock/">Lock</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/2020/05/12/Design-Patterns/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">设计模式汇总</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/2020/05/01/Java-AQS/">
            <span class="next-text nav-default">Java 中的 AQS</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'SirCarol';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://twitter.com/SirCarol_" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://github.com/dyfloveslife" class="iconfont icon-github" title="github"></a>
  
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Carol</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"  integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>








</body>
</html>
